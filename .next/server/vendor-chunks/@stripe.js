"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stripe";
exports.ids = ["vendor-chunks/@stripe"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressElement: () => (/* binding */ AddressElement),\n/* harmony export */   AffirmMessageElement: () => (/* binding */ AffirmMessageElement),\n/* harmony export */   AfterpayClearpayMessageElement: () => (/* binding */ AfterpayClearpayMessageElement),\n/* harmony export */   AuBankAccountElement: () => (/* binding */ AuBankAccountElement),\n/* harmony export */   CardCvcElement: () => (/* binding */ CardCvcElement),\n/* harmony export */   CardElement: () => (/* binding */ CardElement),\n/* harmony export */   CardExpiryElement: () => (/* binding */ CardExpiryElement),\n/* harmony export */   CardNumberElement: () => (/* binding */ CardNumberElement),\n/* harmony export */   CartElement: () => (/* binding */ CartElement),\n/* harmony export */   CustomCheckoutProvider: () => (/* binding */ CustomCheckoutProvider),\n/* harmony export */   Elements: () => (/* binding */ Elements),\n/* harmony export */   ElementsConsumer: () => (/* binding */ ElementsConsumer),\n/* harmony export */   EmbeddedCheckout: () => (/* binding */ EmbeddedCheckout),\n/* harmony export */   EmbeddedCheckoutProvider: () => (/* binding */ EmbeddedCheckoutProvider),\n/* harmony export */   EpsBankElement: () => (/* binding */ EpsBankElement),\n/* harmony export */   ExpressCheckoutElement: () => (/* binding */ ExpressCheckoutElement),\n/* harmony export */   FpxBankElement: () => (/* binding */ FpxBankElement),\n/* harmony export */   IbanElement: () => (/* binding */ IbanElement),\n/* harmony export */   IdealBankElement: () => (/* binding */ IdealBankElement),\n/* harmony export */   LinkAuthenticationElement: () => (/* binding */ LinkAuthenticationElement),\n/* harmony export */   P24BankElement: () => (/* binding */ P24BankElement),\n/* harmony export */   PaymentElement: () => (/* binding */ PaymentElement),\n/* harmony export */   PaymentMethodMessagingElement: () => (/* binding */ PaymentMethodMessagingElement),\n/* harmony export */   PaymentRequestButtonElement: () => (/* binding */ PaymentRequestButtonElement),\n/* harmony export */   ShippingAddressElement: () => (/* binding */ ShippingAddressElement),\n/* harmony export */   useCartElement: () => (/* binding */ useCartElement),\n/* harmony export */   useCartElementState: () => (/* binding */ useCartElementState),\n/* harmony export */   useCustomCheckout: () => (/* binding */ useCustomCheckout),\n/* harmony export */   useElements: () => (/* binding */ useElements),\n/* harmony export */   useStripe: () => (/* binding */ useStripe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function(obj) {\n            return typeof obj;\n        };\n    } else {\n        _typeof = function(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n    }\n    return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar usePrevious = function usePrevious(value) {\n    var ref = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(value);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n};\nvar isUnknownObject = function isUnknownObject(raw) {\n    return raw !== null && _typeof(raw) === \"object\";\n};\nvar isPromise = function isPromise(raw) {\n    return isUnknownObject(raw) && typeof raw.then === \"function\";\n}; // We are using types to enforce the `stripe` prop in this lib,\n// but in an untyped integration `stripe` could be anything, so we need\n// to do some sanity validation to prevent type errors.\nvar isStripe = function isStripe(raw) {\n    return isUnknownObject(raw) && typeof raw.elements === \"function\" && typeof raw.createToken === \"function\" && typeof raw.createPaymentMethod === \"function\" && typeof raw.confirmCardPayment === \"function\";\n};\nvar PLAIN_OBJECT_STR = \"[object Object]\";\nvar isEqual = function isEqual(left, right) {\n    if (!isUnknownObject(left) || !isUnknownObject(right)) {\n        return left === right;\n    }\n    var leftArray = Array.isArray(left);\n    var rightArray = Array.isArray(right);\n    if (leftArray !== rightArray) return false;\n    var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n    var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n    if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so\n    // fallback to reference check.\n    if (!leftPlainObject && !leftArray) return left === right;\n    var leftKeys = Object.keys(left);\n    var rightKeys = Object.keys(right);\n    if (leftKeys.length !== rightKeys.length) return false;\n    var keySet = {};\n    for(var i = 0; i < leftKeys.length; i += 1){\n        keySet[leftKeys[i]] = true;\n    }\n    for(var _i = 0; _i < rightKeys.length; _i += 1){\n        keySet[rightKeys[_i]] = true;\n    }\n    var allKeys = Object.keys(keySet);\n    if (allKeys.length !== leftKeys.length) {\n        return false;\n    }\n    var l = left;\n    var r = right;\n    var pred = function pred(key) {\n        return isEqual(l[key], r[key]);\n    };\n    return allKeys.every(pred);\n};\nvar extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {\n    if (!isUnknownObject(options)) {\n        return null;\n    }\n    return Object.keys(options).reduce(function(newOptions, key) {\n        var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n        if (immutableKeys.includes(key)) {\n            if (isUpdated) {\n                console.warn(\"Unsupported prop change: options.\".concat(key, \" is not a mutable property.\"));\n            }\n            return newOptions;\n        }\n        if (!isUpdated) {\n            return newOptions;\n        }\n        return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));\n    }, null);\n};\nvar INVALID_STRIPE_ERROR = \"Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\"; // We are using types to enforce the `stripe` prop in this lib, but in a real\n// integration `stripe` could be anything, so we need to do some sanity\n// validation to prevent type errors.\nvar validateStripe = function validateStripe(maybeStripe) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR;\n    if (maybeStripe === null || isStripe(maybeStripe)) {\n        return maybeStripe;\n    }\n    throw new Error(errorMsg);\n};\nvar parseStripeProp = function parseStripeProp(raw) {\n    var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR;\n    if (isPromise(raw)) {\n        return {\n            tag: \"async\",\n            stripePromise: Promise.resolve(raw).then(function(result) {\n                return validateStripe(result, errorMsg);\n            })\n        };\n    }\n    var stripe = validateStripe(raw, errorMsg);\n    if (stripe === null) {\n        return {\n            tag: \"empty\"\n        };\n    }\n    return {\n        tag: \"sync\",\n        stripe: stripe\n    };\n};\nvar registerWithStripeJs = function registerWithStripeJs(stripe) {\n    if (!stripe || !stripe._registerWrapper || !stripe.registerAppInfo) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"react-stripe-js\",\n        version: \"2.5.1\"\n    });\n    stripe.registerAppInfo({\n        name: \"react-stripe-js\",\n        version: \"2.5.1\",\n        url: \"https://stripe.com/docs/stripe-js/react\"\n    });\n};\nvar ElementsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nElementsContext.displayName = \"ElementsContext\";\nvar parseElementsContext = function parseElementsContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\nvar CartElementContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nCartElementContext.displayName = \"CartElementContext\";\nvar parseCartElementContext = function parseCartElementContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n    }\n    return ctx;\n};\n/**\n * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.\n * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.\n *\n * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.\n * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.\n * Pass the returned `Promise` to `Elements`.\n *\n * @docs https://stripe.com/docs/stripe-js/react#elements-provider\n */ var Elements = function Elements(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return parseStripeProp(rawStripeProp);\n    }, [\n        rawStripeProp\n    ]);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), cart = _React$useState2[0], setCart = _React$useState2[1];\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), cartState = _React$useState4[0], setCartState = _React$useState4[1]; // For a sync stripe instance, initialize into context\n    var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0___default().useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            elements: parsed.tag === \"sync\" ? parsed.stripe.elements(options) : null\n        };\n    }), _React$useState6 = _slicedToArray(_React$useState5, 2), ctx = _React$useState6[0], setContext = _React$useState6[1];\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var isMounted = true;\n        var safeSetContext = function safeSetContext(stripe) {\n            setContext(function(ctx) {\n                // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)\n                if (ctx.stripe) return ctx;\n                return {\n                    stripe: stripe,\n                    elements: stripe.elements(options)\n                };\n            });\n        }; // For an async stripePromise, store it in context once resolved\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted) {\n                    // Only update Elements context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    safeSetContext(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !ctx.stripe) {\n            // Or, handle a sync stripe instance going from null -> populated\n            safeSetContext(parsed.stripe);\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!ctx.elements) {\n            return;\n        }\n        var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n            \"clientSecret\",\n            \"fonts\"\n        ]);\n        if (updates) {\n            ctx.elements.update(updates);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.elements\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        registerWithStripeJs(ctx.stripe);\n    }, [\n        ctx.stripe\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ElementsContext.Provider, {\n        value: ctx\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CartElementContext.Provider, {\n        value: {\n            cart: cart,\n            setCart: setCart,\n            cartState: cartState,\n            setCartState: setCartState\n        }\n    }, children));\n};\nElements.propTypes = {\n    stripe: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().any),\n    options: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)\n};\nvar useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(ElementsContext);\n    return parseElementsContext(ctx, useCaseMessage);\n};\nvar DUMMY_CART_ELEMENT_CONTEXT = {\n    cart: null,\n    cartState: null,\n    setCart: function setCart() {},\n    setCartState: function setCartState() {}\n};\nvar useCartElementContextWithUseCase = function useCartElementContextWithUseCase(useCaseMessage) {\n    var isInCustomCheckout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(CartElementContext);\n    if (isInCustomCheckout) {\n        return DUMMY_CART_ELEMENT_CONTEXT;\n    }\n    return parseCartElementContext(ctx, useCaseMessage);\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#useelements-hook\n */ var useElements = function useElements() {\n    var _useElementsContextWi = useElementsContextWithUseCase(\"calls useElements()\"), elements = _useElementsContextWi.elements;\n    return elements;\n};\n/**\n * @docs https://stripe.com/docs/payments/checkout/cart-element\n */ var useCartElement = function useCartElement() {\n    var _useCartElementContex = useCartElementContextWithUseCase(\"calls useCartElement()\"), cart = _useCartElementContex.cart;\n    return cart;\n};\n/**\n * @docs https://stripe.com/docs/payments/checkout/cart-element\n */ var useCartElementState = function useCartElementState() {\n    var _useCartElementContex2 = useCartElementContextWithUseCase(\"calls useCartElementState()\"), cartState = _useCartElementContex2.cartState;\n    return cartState;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#elements-consumer\n */ var ElementsConsumer = function ElementsConsumer(_ref2) {\n    var children = _ref2.children;\n    var ctx = useElementsContextWithUseCase(\"mounts <ElementsConsumer>\"); // Assert to satisfy the busted React.FC return type (it should be ReactNode)\n    return children(ctx);\n};\nElementsConsumer.propTypes = {\n    children: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func).isRequired\n};\nvar useAttachEvent = function useAttachEvent(element, event, cb) {\n    var cbDefined = !!cb;\n    var cbRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(cb); // In many integrations the callback prop changes on each render.\n    // Using a ref saves us from calling element.on/.off every render.\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        cbRef.current = cb;\n    }, [\n        cb\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!cbDefined || !element) {\n            return function() {};\n        }\n        var decoratedCb = function decoratedCb() {\n            if (cbRef.current) {\n                cbRef.current.apply(cbRef, arguments);\n            }\n        };\n        element.on(event, decoratedCb);\n        return function() {\n            element.off(event, decoratedCb);\n        };\n    }, [\n        cbDefined,\n        event,\n        element,\n        cbRef\n    ]);\n};\nvar _excluded = [\n    \"on\",\n    \"session\"\n];\nvar CustomCheckoutSdkContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nCustomCheckoutSdkContext.displayName = \"CustomCheckoutSdkContext\";\nvar parseCustomCheckoutSdkContext = function parseCustomCheckoutSdkContext(ctx, useCase) {\n    if (!ctx) {\n        throw new Error(\"Could not find CustomCheckoutProvider context; You need to wrap the part of your app that \".concat(useCase, \" in an <CustomCheckoutProvider> provider.\"));\n    }\n    return ctx;\n};\nvar CustomCheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nCustomCheckoutContext.displayName = \"CustomCheckoutContext\";\nvar extractCustomCheckoutContextValue = function extractCustomCheckoutContextValue(customCheckoutSdk, sessionState) {\n    if (!customCheckoutSdk) {\n        return null;\n    }\n    var _on = customCheckoutSdk.on, _session = customCheckoutSdk.session, actions = _objectWithoutProperties(customCheckoutSdk, _excluded);\n    if (!sessionState) {\n        return _objectSpread2(_objectSpread2({}, actions), customCheckoutSdk.session());\n    }\n    return _objectSpread2(_objectSpread2({}, actions), sessionState);\n};\nvar INVALID_STRIPE_ERROR$1 = \"Invalid prop `stripe` supplied to `CustomCheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar CustomCheckoutProvider = function CustomCheckoutProvider(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR$1);\n    }, [\n        rawStripeProp\n    ]); // State used to trigger a re-render when sdk.session is updated\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), session = _React$useState2[0], setSession = _React$useState2[1];\n    var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0___default().useState(function() {\n        return {\n            stripe: parsed.tag === \"sync\" ? parsed.stripe : null,\n            customCheckoutSdk: null\n        };\n    }), _React$useState4 = _slicedToArray(_React$useState3, 2), ctx = _React$useState4[0], setContext = _React$useState4[1];\n    var safeSetContext = function safeSetContext(stripe, customCheckoutSdk) {\n        setContext(function(ctx) {\n            if (ctx.stripe && ctx.customCheckoutSdk) {\n                return ctx;\n            }\n            return {\n                stripe: stripe,\n                customCheckoutSdk: customCheckoutSdk\n            };\n        });\n    }; // Ref used to avoid calling initCustomCheckout multiple times when options changes\n    var initCustomCheckoutCalledRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(false);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var isMounted = true;\n        if (parsed.tag === \"async\" && !ctx.stripe) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe && isMounted && !initCustomCheckoutCalledRef.current) {\n                    // Only update context if the component is still mounted\n                    // and stripe is not null. We allow stripe to be null to make\n                    // handling SSR easier.\n                    initCustomCheckoutCalledRef.current = true;\n                    stripe.initCustomCheckout(options).then(function(customCheckoutSdk) {\n                        if (customCheckoutSdk) {\n                            safeSetContext(stripe, customCheckoutSdk);\n                            customCheckoutSdk.on(\"change\", setSession);\n                        }\n                    });\n                }\n            });\n        } else if (parsed.tag === \"sync\" && parsed.stripe && !initCustomCheckoutCalledRef.current) {\n            initCustomCheckoutCalledRef.current = true;\n            parsed.stripe.initCustomCheckout(options).then(function(customCheckoutSdk) {\n                if (customCheckoutSdk) {\n                    safeSetContext(parsed.stripe, customCheckoutSdk);\n                    customCheckoutSdk.on(\"change\", setSession);\n                }\n            });\n        }\n        return function() {\n            isMounted = false;\n        };\n    }, [\n        parsed,\n        ctx,\n        options,\n        setSession\n    ]); // Warn on changes to stripe prop\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on CustomCheckoutProvider: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Apply updates to elements when options prop has relevant changes\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var _prevOptions$elements, _options$elementsOpti;\n        if (!ctx.customCheckoutSdk) {\n            return;\n        }\n        if (options.clientSecret && !isUnknownObject(prevOptions) && !isEqual(options.clientSecret, prevOptions.clientSecret)) {\n            console.warn(\"Unsupported prop change: options.client_secret is not a mutable property.\");\n        }\n        var previousAppearance = prevOptions === null || prevOptions === void 0 ? void 0 : (_prevOptions$elements = prevOptions.elementsOptions) === null || _prevOptions$elements === void 0 ? void 0 : _prevOptions$elements.appearance;\n        var currentAppearance = options === null || options === void 0 ? void 0 : (_options$elementsOpti = options.elementsOptions) === null || _options$elementsOpti === void 0 ? void 0 : _options$elementsOpti.appearance;\n        if (currentAppearance && !isEqual(currentAppearance, previousAppearance)) {\n            ctx.customCheckoutSdk.changeAppearance(currentAppearance);\n        }\n    }, [\n        options,\n        prevOptions,\n        ctx.customCheckoutSdk\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        registerWithStripeJs(ctx.stripe);\n    }, [\n        ctx.stripe\n    ]);\n    var customCheckoutContextValue = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return extractCustomCheckoutContextValue(ctx.customCheckoutSdk, session);\n    }, [\n        ctx.customCheckoutSdk,\n        session\n    ]);\n    if (!ctx.customCheckoutSdk) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomCheckoutSdkContext.Provider, {\n        value: ctx\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomCheckoutContext.Provider, {\n        value: customCheckoutContextValue\n    }, children));\n};\nCustomCheckoutProvider.propTypes = {\n    stripe: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().any),\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1___default().shape({\n        clientSecret: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string).isRequired,\n        elementsOptions: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)\n    }).isRequired\n};\nvar useCustomCheckoutSdkContextWithUseCase = function useCustomCheckoutSdkContextWithUseCase(useCaseString) {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(CustomCheckoutSdkContext);\n    return parseCustomCheckoutSdkContext(ctx, useCaseString);\n};\nvar useElementsOrCustomCheckoutSdkContextWithUseCase = function useElementsOrCustomCheckoutSdkContextWithUseCase(useCaseString) {\n    var customCheckoutSdkContext = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(CustomCheckoutSdkContext);\n    var elementsContext = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(ElementsContext);\n    if (customCheckoutSdkContext && elementsContext) {\n        throw new Error(\"You cannot wrap the part of your app that \".concat(useCaseString, \" in both <CustomCheckoutProvider> and <Elements> providers.\"));\n    }\n    if (customCheckoutSdkContext) {\n        return parseCustomCheckoutSdkContext(customCheckoutSdkContext, useCaseString);\n    }\n    return parseElementsContext(elementsContext, useCaseString);\n};\nvar useCustomCheckout = function useCustomCheckout() {\n    // ensure it's in CustomCheckoutProvider\n    useCustomCheckoutSdkContextWithUseCase(\"calls useCustomCheckout()\");\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(CustomCheckoutContext);\n    if (!ctx) {\n        throw new Error(\"Could not find CustomCheckout Context; You need to wrap the part of your app that calls useCustomCheckout() in an <CustomCheckoutProvider> provider.\");\n    }\n    return ctx;\n};\nvar capitalized = function capitalized(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nvar createElementComponent = function createElementComponent(type, isServer) {\n    var displayName = \"\".concat(capitalized(type), \"Element\");\n    var ClientElement = function ClientElement(_ref) {\n        var id = _ref.id, className = _ref.className, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, onBlur = _ref.onBlur, onFocus = _ref.onFocus, onReady = _ref.onReady, onChange = _ref.onChange, onEscape = _ref.onEscape, onClick = _ref.onClick, onLoadError = _ref.onLoadError, onLoaderStart = _ref.onLoaderStart, onNetworksChange = _ref.onNetworksChange, onCheckout = _ref.onCheckout, onLineItemClick = _ref.onLineItemClick, onConfirm = _ref.onConfirm, onCancel = _ref.onCancel, onShippingAddressChange = _ref.onShippingAddressChange, onShippingRateChange = _ref.onShippingRateChange;\n        var ctx = useElementsOrCustomCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        var elements = \"elements\" in ctx ? ctx.elements : null;\n        var customCheckoutSdk = \"customCheckoutSdk\" in ctx ? ctx.customCheckoutSdk : null;\n        var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), element = _React$useState2[0], setElement = _React$useState2[1];\n        var elementRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n        var domNode = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n        var _useCartElementContex = useCartElementContextWithUseCase(\"mounts <\".concat(displayName, \">\"), \"customCheckoutSdk\" in ctx), setCart = _useCartElementContex.setCart, setCartState = _useCartElementContex.setCartState; // For every event where the merchant provides a callback, call element.on\n        // with that callback. If the merchant ever changes the callback, removes\n        // the old callback with element.off and then call element.on with the new one.\n        useAttachEvent(element, \"blur\", onBlur);\n        useAttachEvent(element, \"focus\", onFocus);\n        useAttachEvent(element, \"escape\", onEscape);\n        useAttachEvent(element, \"click\", onClick);\n        useAttachEvent(element, \"loaderror\", onLoadError);\n        useAttachEvent(element, \"loaderstart\", onLoaderStart);\n        useAttachEvent(element, \"networkschange\", onNetworksChange);\n        useAttachEvent(element, \"lineitemclick\", onLineItemClick);\n        useAttachEvent(element, \"confirm\", onConfirm);\n        useAttachEvent(element, \"cancel\", onCancel);\n        useAttachEvent(element, \"shippingaddresschange\", onShippingAddressChange);\n        useAttachEvent(element, \"shippingratechange\", onShippingRateChange);\n        var readyCallback;\n        if (type === \"cart\") {\n            readyCallback = function readyCallback(event) {\n                setCartState(event);\n                onReady && onReady(event);\n            };\n        } else if (onReady) {\n            if (type === \"expressCheckout\") {\n                // Passes through the event, which includes visible PM types\n                readyCallback = onReady;\n            } else {\n                // For other Elements, pass through the Element itself.\n                readyCallback = function readyCallback() {\n                    onReady(element);\n                };\n            }\n        }\n        useAttachEvent(element, \"ready\", readyCallback);\n        var changeCallback = type === \"cart\" ? function(event) {\n            setCartState(event);\n            onChange && onChange(event);\n        } : onChange;\n        useAttachEvent(element, \"change\", changeCallback);\n        var checkoutCallback = type === \"cart\" ? function(event) {\n            setCartState(event);\n            onCheckout && onCheckout(event);\n        } : onCheckout;\n        useAttachEvent(element, \"checkout\", checkoutCallback);\n        react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect(function() {\n            if (elementRef.current === null && domNode.current !== null && (elements || customCheckoutSdk)) {\n                var newElement = null;\n                if (customCheckoutSdk) {\n                    newElement = customCheckoutSdk.createElement(type, options);\n                } else if (elements) {\n                    newElement = elements.create(type, options);\n                }\n                if (type === \"cart\" && setCart) {\n                    // we know that elements.create return value must be of type StripeCartElement if type is 'cart',\n                    // we need to cast because typescript is not able to infer which overloaded method is used based off param type\n                    setCart(newElement);\n                } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode\n                elementRef.current = newElement; // Store element in state to facilitate event listener attachment\n                setElement(newElement);\n                if (newElement) {\n                    newElement.mount(domNode.current);\n                }\n            }\n        }, [\n            elements,\n            customCheckoutSdk,\n            options,\n            setCart\n        ]);\n        var prevOptions = usePrevious(options);\n        react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n            if (!elementRef.current) {\n                return;\n            }\n            var updates = extractAllowedOptionsUpdates(options, prevOptions, [\n                \"paymentRequest\"\n            ]);\n            if (updates) {\n                elementRef.current.update(updates);\n            }\n        }, [\n            options,\n            prevOptions\n        ]);\n        react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect(function() {\n            return function() {\n                if (elementRef.current && typeof elementRef.current.destroy === \"function\") {\n                    try {\n                        elementRef.current.destroy();\n                        elementRef.current = null;\n                    } catch (error) {}\n                }\n            };\n        }, []);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            id: id,\n            className: className,\n            ref: domNode\n        });\n    }; // Only render the Element wrapper in a server environment.\n    var ServerElement = function ServerElement(props) {\n        // Validate that we are in the right context by calling useElementsContextWithUseCase.\n        var ctx = useElementsOrCustomCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n        useCartElementContextWithUseCase(\"mounts <\".concat(displayName, \">\"), \"customCheckoutSdk\" in ctx);\n        var id = props.id, className = props.className;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            id: id,\n            className: className\n        });\n    };\n    var Element = isServer ? ServerElement : ClientElement;\n    Element.propTypes = {\n        id: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n        className: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n        onChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onBlur: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onFocus: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onReady: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onEscape: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onLoadError: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onLoaderStart: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onNetworksChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onCheckout: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onLineItemClick: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onConfirm: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onCancel: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onShippingAddressChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        onShippingRateChange: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func),\n        options: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)\n    };\n    Element.displayName = displayName;\n    Element.__elementType = type;\n    return Element;\n};\nvar isServer = \"undefined\" === \"undefined\";\nvar EmbeddedCheckoutContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nEmbeddedCheckoutContext.displayName = \"EmbeddedCheckoutProviderContext\";\nvar useEmbeddedCheckoutContext = function useEmbeddedCheckoutContext() {\n    var ctx = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(EmbeddedCheckoutContext);\n    if (!ctx) {\n        throw new Error(\"<EmbeddedCheckout> must be used within <EmbeddedCheckoutProvider>\");\n    }\n    return ctx;\n};\nvar INVALID_STRIPE_ERROR$2 = \"Invalid prop `stripe` supplied to `EmbeddedCheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.\";\nvar EmbeddedCheckoutProvider = function EmbeddedCheckoutProvider(_ref) {\n    var rawStripeProp = _ref.stripe, options = _ref.options, children = _ref.children;\n    var parsed = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR$2);\n    }, [\n        rawStripeProp\n    ]);\n    var embeddedCheckoutPromise = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    var loadedStripe = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0___default().useState({\n        embeddedCheckout: null\n    }), _React$useState2 = _slicedToArray(_React$useState, 2), ctx = _React$useState2[0], setContext = _React$useState2[1];\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        // Don't support any ctx updates once embeddedCheckout or stripe is set.\n        if (loadedStripe.current || embeddedCheckoutPromise.current) {\n            return;\n        }\n        var setStripeAndInitEmbeddedCheckout = function setStripeAndInitEmbeddedCheckout(stripe) {\n            if (loadedStripe.current || embeddedCheckoutPromise.current) return;\n            loadedStripe.current = stripe;\n            embeddedCheckoutPromise.current = loadedStripe.current.initEmbeddedCheckout(options).then(function(embeddedCheckout) {\n                setContext({\n                    embeddedCheckout: embeddedCheckout\n                });\n            });\n        }; // For an async stripePromise, store it once resolved\n        if (parsed.tag === \"async\" && !loadedStripe.current && options.clientSecret) {\n            parsed.stripePromise.then(function(stripe) {\n                if (stripe) {\n                    setStripeAndInitEmbeddedCheckout(stripe);\n                }\n            });\n        } else if (parsed.tag === \"sync\" && !loadedStripe.current && options.clientSecret) {\n            // Or, handle a sync stripe instance going from null -> populated\n            setStripeAndInitEmbeddedCheckout(parsed.stripe);\n        }\n    }, [\n        parsed,\n        options,\n        ctx,\n        loadedStripe\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        // cleanup on unmount\n        return function() {\n            // If embedded checkout is fully initialized, destroy it.\n            if (ctx.embeddedCheckout) {\n                embeddedCheckoutPromise.current = null;\n                ctx.embeddedCheckout.destroy();\n            } else if (embeddedCheckoutPromise.current) {\n                // If embedded checkout is still initializing, destroy it once\n                // it's done. This could be caused by unmounting very quickly\n                // after mounting.\n                embeddedCheckoutPromise.current.then(function() {\n                    embeddedCheckoutPromise.current = null;\n                    if (ctx.embeddedCheckout) {\n                        ctx.embeddedCheckout.destroy();\n                    }\n                });\n            }\n        };\n    }, [\n        ctx.embeddedCheckout\n    ]); // Attach react-stripe-js version to stripe.js instance\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        registerWithStripeJs(loadedStripe);\n    }, [\n        loadedStripe\n    ]); // Warn on changes to stripe prop.\n    // The stripe prop value can only go from null to non-null once and\n    // can't be changed after that.\n    var prevStripe = usePrevious(rawStripeProp);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (prevStripe !== null && prevStripe !== rawStripeProp) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the `stripe` prop after setting it.\");\n        }\n    }, [\n        prevStripe,\n        rawStripeProp\n    ]); // Warn on changes to options.\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (prevOptions == null) {\n            return;\n        }\n        if (options == null) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot unset options after setting them.\");\n            return;\n        }\n        if (prevOptions.clientSecret != null && options.clientSecret !== prevOptions.clientSecret) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the client secret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.\");\n        }\n        if (prevOptions.onComplete != null && options.onComplete !== prevOptions.onComplete) {\n            console.warn(\"Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onComplete option after setting it.\");\n        }\n    }, [\n        prevOptions,\n        options\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(EmbeddedCheckoutContext.Provider, {\n        value: ctx\n    }, children);\n};\nvar EmbeddedCheckoutClientElement = function EmbeddedCheckoutClientElement(_ref) {\n    var id = _ref.id, className = _ref.className;\n    var _useEmbeddedCheckoutC = useEmbeddedCheckoutContext(), embeddedCheckout = _useEmbeddedCheckoutC.embeddedCheckout;\n    var isMounted = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(false);\n    var domNode = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useLayoutEffect(function() {\n        if (!isMounted.current && embeddedCheckout && domNode.current !== null) {\n            embeddedCheckout.mount(domNode.current);\n            isMounted.current = true;\n        } // Clean up on unmount\n        return function() {\n            if (isMounted.current && embeddedCheckout) {\n                try {\n                    embeddedCheckout.unmount();\n                    isMounted.current = false;\n                } catch (e) {\n                // Parent effects are destroyed before child effects, so\n                // in cases where both the EmbeddedCheckoutProvider and\n                // the EmbeddedCheckout component are removed at the same\n                // time, the embeddedCheckout instance will be destroyed,\n                // which causes an error when calling unmount.\n                }\n            }\n        };\n    }, [\n        embeddedCheckout\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        ref: domNode,\n        id: id,\n        className: className\n    });\n}; // Only render the wrapper in a server environment.\nvar EmbeddedCheckoutServerElement = function EmbeddedCheckoutServerElement(_ref2) {\n    var id = _ref2.id, className = _ref2.className;\n    // Validate that we are in the right context by calling useEmbeddedCheckoutContext.\n    useEmbeddedCheckoutContext();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        id: id,\n        className: className\n    });\n};\nvar EmbeddedCheckout = isServer ? EmbeddedCheckoutServerElement : EmbeddedCheckoutClientElement;\n/**\n * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook\n */ var useStripe = function useStripe() {\n    var _useElementsOrCustomC = useElementsOrCustomCheckoutSdkContextWithUseCase(\"calls useStripe()\"), stripe = _useElementsOrCustomC.stripe;\n    return stripe;\n};\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AuBankAccountElement = createElementComponent(\"auBankAccount\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardElement = createElementComponent(\"card\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardNumberElement = createElementComponent(\"cardNumber\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardExpiryElement = createElementComponent(\"cardExpiry\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var CardCvcElement = createElementComponent(\"cardCvc\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var FpxBankElement = createElementComponent(\"fpxBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IbanElement = createElementComponent(\"iban\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var IdealBankElement = createElementComponent(\"idealBank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var P24BankElement = createElementComponent(\"p24Bank\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var EpsBankElement = createElementComponent(\"epsBank\", isServer);\nvar PaymentElement = createElementComponent(\"payment\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ExpressCheckoutElement = createElementComponent(\"expressCheckout\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentRequestButtonElement = createElementComponent(\"paymentRequestButton\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var LinkAuthenticationElement = createElementComponent(\"linkAuthentication\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AddressElement = createElementComponent(\"address\", isServer);\n/**\n * @deprecated\n * Use `AddressElement` instead.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var ShippingAddressElement = createElementComponent(\"shippingAddress\", isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/elements/cart-element\n */ var CartElement = createElementComponent(\"cart\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var PaymentMethodMessagingElement = createElementComponent(\"paymentMethodMessaging\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AffirmMessageElement = createElementComponent(\"affirmMessage\", isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */ var AfterpayClearpayMessageElement = createElementComponent(\"afterpayClearpayMessage\", isServer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDUztBQUVuQyxTQUFTRSxRQUFRQyxNQUFNLEVBQUVDLGNBQWM7SUFDckMsSUFBSUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDRjtJQUV2QixJQUFJRyxPQUFPQyxxQkFBcUIsRUFBRTtRQUNoQyxJQUFJQyxVQUFVRixPQUFPQyxxQkFBcUIsQ0FBQ0o7UUFFM0MsSUFBSUMsZ0JBQWdCO1lBQ2xCSSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztnQkFDcEMsT0FBT0osT0FBT0ssd0JBQXdCLENBQUNSLFFBQVFPLEtBQUtFLFVBQVU7WUFDaEU7UUFDRjtRQUVBUCxLQUFLUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsTUFBTUc7SUFDeEI7SUFFQSxPQUFPSDtBQUNUO0FBRUEsU0FBU1UsZUFBZUMsTUFBTTtJQUM1QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1FBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRSxJQUFJLE9BQU9DLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHLENBQUM7UUFFcEQsSUFBSUEsSUFBSSxHQUFHO1lBQ1RmLFFBQVFJLE9BQU9jLFNBQVMsTUFBTUMsT0FBTyxDQUFDLFNBQVVDLEdBQUc7Z0JBQ2pEQyxnQkFBZ0JQLFFBQVFNLEtBQUtGLE1BQU0sQ0FBQ0UsSUFBSTtZQUMxQztRQUNGLE9BQU8sSUFBSWhCLE9BQU9rQix5QkFBeUIsRUFBRTtZQUMzQ2xCLE9BQU9tQixnQkFBZ0IsQ0FBQ1QsUUFBUVYsT0FBT2tCLHlCQUF5QixDQUFDSjtRQUNuRSxPQUFPO1lBQ0xsQixRQUFRSSxPQUFPYyxTQUFTQyxPQUFPLENBQUMsU0FBVUMsR0FBRztnQkFDM0NoQixPQUFP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O0FBQ2pEOztDQUVDLEdBRUQsSUFBSXVFLGdDQUFnQ3pFLHVCQUF1QiwwQkFBMEJFO0FBQ3JGOztDQUVDLEdBRUQsSUFBSXdFLHVCQUF1QjFFLHVCQUF1QixpQkFBaUJFO0FBQ25FOztDQUVDLEdBRUQsSUFBSXlFLGlDQUFpQzNFLHVCQUF1QiwyQkFBMkJFO0FBRXFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicHJvZGlnaWVzLXBsdXJhLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2Rpc3QvcmVhY3Qtc3RyaXBlLmVzbS5qcz9iNWViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG5cbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciAmJiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdKTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgdXNlUHJldmlvdXMgPSBmdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufTtcblxudmFyIGlzVW5rbm93bk9iamVjdCA9IGZ1bmN0aW9uIGlzVW5rbm93bk9iamVjdChyYXcpIHtcbiAgcmV0dXJuIHJhdyAhPT0gbnVsbCAmJiBfdHlwZW9mKHJhdykgPT09ICdvYmplY3QnO1xufTtcbnZhciBpc1Byb21pc2UgPSBmdW5jdGlvbiBpc1Byb21pc2UocmF3KSB7XG4gIHJldHVybiBpc1Vua25vd25PYmplY3QocmF3KSAmJiB0eXBlb2YgcmF3LnRoZW4gPT09ICdmdW5jdGlvbic7XG59OyAvLyBXZSBhcmUgdXNpbmcgdHlwZXMgdG8gZW5mb3JjZSB0aGUgYHN0cmlwZWAgcHJvcCBpbiB0aGlzIGxpYixcbi8vIGJ1dCBpbiBhbiB1bnR5cGVkIGludGVncmF0aW9uIGBzdHJpcGVgIGNvdWxkIGJlIGFueXRoaW5nLCBzbyB3ZSBuZWVkXG4vLyB0byBkbyBzb21lIHNhbml0eSB2YWxpZGF0aW9uIHRvIHByZXZlbnQgdHlwZSBlcnJvcnMuXG5cbnZhciBpc1N0cmlwZSA9IGZ1bmN0aW9uIGlzU3RyaXBlKHJhdykge1xuICByZXR1cm4gaXNVbmtub3duT2JqZWN0KHJhdykgJiYgdHlwZW9mIHJhdy5lbGVtZW50cyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNyZWF0ZVRva2VuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByYXcuY3JlYXRlUGF5bWVudE1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNvbmZpcm1DYXJkUGF5bWVudCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBQTEFJTl9PQkpFQ1RfU1RSID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgaWYgKCFpc1Vua25vd25PYmplY3QobGVmdCkgfHwgIWlzVW5rbm93bk9iamVjdChyaWdodCkpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH1cblxuICB2YXIgbGVmdEFycmF5ID0gQXJyYXkuaXNBcnJheShsZWZ0KTtcbiAgdmFyIHJpZ2h0QXJyYXkgPSBBcnJheS5pc0FycmF5KHJpZ2h0KTtcbiAgaWYgKGxlZnRBcnJheSAhPT0gcmlnaHRBcnJheSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgbGVmdFBsYWluT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGxlZnQpID09PSBQTEFJTl9PQkpFQ1RfU1RSO1xuICB2YXIgcmlnaHRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyaWdodCkgPT09IFBMQUlOX09CSkVDVF9TVFI7XG4gIGlmIChsZWZ0UGxhaW5PYmplY3QgIT09IHJpZ2h0UGxhaW5PYmplY3QpIHJldHVybiBmYWxzZTsgLy8gbm90IHN1cmUgd2hhdCBzb3J0IG9mIHNwZWNpYWwgb2JqZWN0IHRoaXMgaXMgKHJlZ2V4cCBpcyBvbmUgb3B0aW9uKSwgc29cbiAgLy8gZmFsbGJhY2sgdG8gcmVmZXJlbmNlIGNoZWNrLlxuXG4gIGlmICghbGVmdFBsYWluT2JqZWN0ICYmICFsZWZ0QXJyYXkpIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgdmFyIGxlZnRLZXlzID0gT2JqZWN0LmtleXMobGVmdCk7XG4gIHZhciByaWdodEtleXMgPSBPYmplY3Qua2V5cyhyaWdodCk7XG4gIGlmIChsZWZ0S2V5cy5sZW5ndGggIT09IHJpZ2h0S2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtleVNldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBrZXlTZXRbbGVmdEtleXNbaV1dID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCByaWdodEtleXMubGVuZ3RoOyBfaSArPSAxKSB7XG4gICAga2V5U2V0W3JpZ2h0S2V5c1tfaV1dID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gT2JqZWN0LmtleXMoa2V5U2V0KTtcblxuICBpZiAoYWxsS2V5cy5sZW5ndGggIT09IGxlZnRLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsID0gbGVmdDtcbiAgdmFyIHIgPSByaWdodDtcblxuICB2YXIgcHJlZCA9IGZ1bmN0aW9uIHByZWQoa2V5KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobFtrZXldLCByW2tleV0pO1xuICB9O1xuXG4gIHJldHVybiBhbGxLZXlzLmV2ZXJ5KHByZWQpO1xufTtcblxudmFyIGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMgPSBmdW5jdGlvbiBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzKG9wdGlvbnMsIHByZXZPcHRpb25zLCBpbW11dGFibGVLZXlzKSB7XG4gIGlmICghaXNVbmtub3duT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKGZ1bmN0aW9uIChuZXdPcHRpb25zLCBrZXkpIHtcbiAgICB2YXIgaXNVcGRhdGVkID0gIWlzVW5rbm93bk9iamVjdChwcmV2T3B0aW9ucykgfHwgIWlzRXF1YWwob3B0aW9uc1trZXldLCBwcmV2T3B0aW9uc1trZXldKTtcblxuICAgIGlmIChpbW11dGFibGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGlmIChpc1VwZGF0ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2U6IG9wdGlvbnMuXCIuY29uY2F0KGtleSwgXCIgaXMgbm90IGEgbXV0YWJsZSBwcm9wZXJ0eS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3T3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoIWlzVXBkYXRlZCkge1xuICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBuZXdPcHRpb25zIHx8IHt9KSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBvcHRpb25zW2tleV0pKTtcbiAgfSwgbnVsbCk7XG59O1xuXG52YXIgSU5WQUxJRF9TVFJJUEVfRVJST1IgPSAnSW52YWxpZCBwcm9wIGBzdHJpcGVgIHN1cHBsaWVkIHRvIGBFbGVtZW50c2AuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYGxvYWRTdHJpcGVgIHV0aWxpdHkgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgLiBTZWUgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3BzLXN0cmlwZSBmb3IgZGV0YWlscy4nOyAvLyBXZSBhcmUgdXNpbmcgdHlwZXMgdG8gZW5mb3JjZSB0aGUgYHN0cmlwZWAgcHJvcCBpbiB0aGlzIGxpYiwgYnV0IGluIGEgcmVhbFxuLy8gaW50ZWdyYXRpb24gYHN0cmlwZWAgY291bGQgYmUgYW55dGhpbmcsIHNvIHdlIG5lZWQgdG8gZG8gc29tZSBzYW5pdHlcbi8vIHZhbGlkYXRpb24gdG8gcHJldmVudCB0eXBlIGVycm9ycy5cblxudmFyIHZhbGlkYXRlU3RyaXBlID0gZnVuY3Rpb24gdmFsaWRhdGVTdHJpcGUobWF5YmVTdHJpcGUpIHtcbiAgdmFyIGVycm9yTXNnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBJTlZBTElEX1NUUklQRV9FUlJPUjtcblxuICBpZiAobWF5YmVTdHJpcGUgPT09IG51bGwgfHwgaXNTdHJpcGUobWF5YmVTdHJpcGUpKSB7XG4gICAgcmV0dXJuIG1heWJlU3RyaXBlO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbn07XG5cbnZhciBwYXJzZVN0cmlwZVByb3AgPSBmdW5jdGlvbiBwYXJzZVN0cmlwZVByb3AocmF3KSB7XG4gIHZhciBlcnJvck1zZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogSU5WQUxJRF9TVFJJUEVfRVJST1I7XG5cbiAgaWYgKGlzUHJvbWlzZShyYXcpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZzogJ2FzeW5jJyxcbiAgICAgIHN0cmlwZVByb21pc2U6IFByb21pc2UucmVzb2x2ZShyYXcpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVTdHJpcGUocmVzdWx0LCBlcnJvck1zZyk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICB2YXIgc3RyaXBlID0gdmFsaWRhdGVTdHJpcGUocmF3LCBlcnJvck1zZyk7XG5cbiAgaWYgKHN0cmlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6ICdlbXB0eSdcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWc6ICdzeW5jJyxcbiAgICBzdHJpcGU6IHN0cmlwZVxuICB9O1xufTtcblxudmFyIHJlZ2lzdGVyV2l0aFN0cmlwZUpzID0gZnVuY3Rpb24gcmVnaXN0ZXJXaXRoU3RyaXBlSnMoc3RyaXBlKSB7XG4gIGlmICghc3RyaXBlIHx8ICFzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlciB8fCAhc3RyaXBlLnJlZ2lzdGVyQXBwSW5mbykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKHtcbiAgICBuYW1lOiAncmVhY3Qtc3RyaXBlLWpzJyxcbiAgICB2ZXJzaW9uOiBcIjIuNS4xXCJcbiAgfSk7XG5cbiAgc3RyaXBlLnJlZ2lzdGVyQXBwSW5mbyh7XG4gICAgbmFtZTogJ3JlYWN0LXN0cmlwZS1qcycsXG4gICAgdmVyc2lvbjogXCIyLjUuMVwiLFxuICAgIHVybDogJ2h0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCdcbiAgfSk7XG59O1xuXG52YXIgRWxlbWVudHNDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5FbGVtZW50c0NvbnRleHQuZGlzcGxheU5hbWUgPSAnRWxlbWVudHNDb250ZXh0JztcbnZhciBwYXJzZUVsZW1lbnRzQ29udGV4dCA9IGZ1bmN0aW9uIHBhcnNlRWxlbWVudHNDb250ZXh0KGN0eCwgdXNlQ2FzZSkge1xuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIEVsZW1lbnRzIGNvbnRleHQ7IFlvdSBuZWVkIHRvIHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBcIi5jb25jYXQodXNlQ2FzZSwgXCIgaW4gYW4gPEVsZW1lbnRzPiBwcm92aWRlci5cIikpO1xuICB9XG5cbiAgcmV0dXJuIGN0eDtcbn07XG52YXIgQ2FydEVsZW1lbnRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5DYXJ0RWxlbWVudENvbnRleHQuZGlzcGxheU5hbWUgPSAnQ2FydEVsZW1lbnRDb250ZXh0JztcbnZhciBwYXJzZUNhcnRFbGVtZW50Q29udGV4dCA9IGZ1bmN0aW9uIHBhcnNlQ2FydEVsZW1lbnRDb250ZXh0KGN0eCwgdXNlQ2FzZSkge1xuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIEVsZW1lbnRzIGNvbnRleHQ7IFlvdSBuZWVkIHRvIHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBcIi5jb25jYXQodXNlQ2FzZSwgXCIgaW4gYW4gPEVsZW1lbnRzPiBwcm92aWRlci5cIikpO1xuICB9XG5cbiAgcmV0dXJuIGN0eDtcbn07XG4vKipcbiAqIFRoZSBgRWxlbWVudHNgIHByb3ZpZGVyIGFsbG93cyB5b3UgdG8gdXNlIFtFbGVtZW50IGNvbXBvbmVudHNdKGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHMpIGFuZCBhY2Nlc3MgdGhlIFtTdHJpcGUgb2JqZWN0XShodHRwczovL3N0cmlwZS5jb20vZG9jcy9qcy9pbml0aWFsaXppbmcpIGluIGFueSBuZXN0ZWQgY29tcG9uZW50LlxuICogUmVuZGVyIGFuIGBFbGVtZW50c2AgcHJvdmlkZXIgYXQgdGhlIHJvb3Qgb2YgeW91ciBSZWFjdCBhcHAgc28gdGhhdCBpdCBpcyBhdmFpbGFibGUgZXZlcnl3aGVyZSB5b3UgbmVlZCBpdC5cbiAqXG4gKiBUbyB1c2UgdGhlIGBFbGVtZW50c2AgcHJvdmlkZXIsIGNhbGwgYGxvYWRTdHJpcGVgIGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYCB3aXRoIHlvdXIgcHVibGlzaGFibGUga2V5LlxuICogVGhlIGBsb2FkU3RyaXBlYCBmdW5jdGlvbiB3aWxsIGFzeW5jaHJvbm91c2x5IGxvYWQgdGhlIFN0cmlwZS5qcyBzY3JpcHQgYW5kIGluaXRpYWxpemUgYSBgU3RyaXBlYCBvYmplY3QuXG4gKiBQYXNzIHRoZSByZXR1cm5lZCBgUHJvbWlzZWAgdG8gYEVsZW1lbnRzYC5cbiAqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudHMtcHJvdmlkZXJcbiAqL1xuXG52YXIgRWxlbWVudHMgPSBmdW5jdGlvbiBFbGVtZW50cyhfcmVmKSB7XG4gIHZhciByYXdTdHJpcGVQcm9wID0gX3JlZi5zdHJpcGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgcGFyc2VkID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlU3RyaXBlUHJvcChyYXdTdHJpcGVQcm9wKTtcbiAgfSwgW3Jhd1N0cmlwZVByb3BdKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgIGNhcnQgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0Q2FydCA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTMgPSBSZWFjdC51c2VTdGF0ZShudWxsKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUzLCAyKSxcbiAgICAgIGNhcnRTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRDYXJ0U3RhdGUgPSBfUmVhY3QkdXNlU3RhdGU0WzFdOyAvLyBGb3IgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSwgaW5pdGlhbGl6ZSBpbnRvIGNvbnRleHRcblxuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGU1ID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpcGU6IHBhcnNlZC50YWcgPT09ICdzeW5jJyA/IHBhcnNlZC5zdHJpcGUgOiBudWxsLFxuICAgICAgZWxlbWVudHM6IHBhcnNlZC50YWcgPT09ICdzeW5jJyA/IHBhcnNlZC5zdHJpcGUuZWxlbWVudHMob3B0aW9ucykgOiBudWxsXG4gICAgfTtcbiAgfSksXG4gICAgICBfUmVhY3QkdXNlU3RhdGU2ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlNSwgMiksXG4gICAgICBjdHggPSBfUmVhY3QkdXNlU3RhdGU2WzBdLFxuICAgICAgc2V0Q29udGV4dCA9IF9SZWFjdCR1c2VTdGF0ZTZbMV07XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNNb3VudGVkID0gdHJ1ZTtcblxuICAgIHZhciBzYWZlU2V0Q29udGV4dCA9IGZ1bmN0aW9uIHNhZmVTZXRDb250ZXh0KHN0cmlwZSkge1xuICAgICAgc2V0Q29udGV4dChmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIC8vIG5vLW9wIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0cmlwZSBpbnN0YW5jZSAoaHR0cHM6Ly9naXRodWIuY29tL3N0cmlwZS9yZWFjdC1zdHJpcGUtanMvaXNzdWVzLzI5NilcbiAgICAgICAgaWYgKGN0eC5zdHJpcGUpIHJldHVybiBjdHg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RyaXBlOiBzdHJpcGUsXG4gICAgICAgICAgZWxlbWVudHM6IHN0cmlwZS5lbGVtZW50cyhvcHRpb25zKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTsgLy8gRm9yIGFuIGFzeW5jIHN0cmlwZVByb21pc2UsIHN0b3JlIGl0IGluIGNvbnRleHQgb25jZSByZXNvbHZlZFxuXG5cbiAgICBpZiAocGFyc2VkLnRhZyA9PT0gJ2FzeW5jJyAmJiAhY3R4LnN0cmlwZSkge1xuICAgICAgcGFyc2VkLnN0cmlwZVByb21pc2UudGhlbihmdW5jdGlvbiAoc3RyaXBlKSB7XG4gICAgICAgIGlmIChzdHJpcGUgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgICAgLy8gT25seSB1cGRhdGUgRWxlbWVudHMgY29udGV4dCBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWRcbiAgICAgICAgICAvLyBhbmQgc3RyaXBlIGlzIG5vdCBudWxsLiBXZSBhbGxvdyBzdHJpcGUgdG8gYmUgbnVsbCB0byBtYWtlXG4gICAgICAgICAgLy8gaGFuZGxpbmcgU1NSIGVhc2llci5cbiAgICAgICAgICBzYWZlU2V0Q29udGV4dChzdHJpcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC50YWcgPT09ICdzeW5jJyAmJiAhY3R4LnN0cmlwZSkge1xuICAgICAgLy8gT3IsIGhhbmRsZSBhIHN5bmMgc3RyaXBlIGluc3RhbmNlIGdvaW5nIGZyb20gbnVsbCAtPiBwb3B1bGF0ZWRcbiAgICAgIHNhZmVTZXRDb250ZXh0KHBhcnNlZC5zdHJpcGUpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbcGFyc2VkLCBjdHgsIG9wdGlvbnNdKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIHN0cmlwZSBwcm9wXG5cbiAgdmFyIHByZXZTdHJpcGUgPSB1c2VQcmV2aW91cyhyYXdTdHJpcGVQcm9wKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldlN0cmlwZSAhPT0gbnVsbCAmJiBwcmV2U3RyaXBlICE9PSByYXdTdHJpcGVQcm9wKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVsZW1lbnRzOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgYHN0cmlwZWAgcHJvcCBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZTdHJpcGUsIHJhd1N0cmlwZVByb3BdKTsgLy8gQXBwbHkgdXBkYXRlcyB0byBlbGVtZW50cyB3aGVuIG9wdGlvbnMgcHJvcCBoYXMgcmVsZXZhbnQgY2hhbmdlc1xuXG4gIHZhciBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY3R4LmVsZW1lbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZXMgPSBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzKG9wdGlvbnMsIHByZXZPcHRpb25zLCBbJ2NsaWVudFNlY3JldCcsICdmb250cyddKTtcblxuICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICBjdHguZWxlbWVudHMudXBkYXRlKHVwZGF0ZXMpO1xuICAgIH1cbiAgfSwgW29wdGlvbnMsIHByZXZPcHRpb25zLCBjdHguZWxlbWVudHNdKTsgLy8gQXR0YWNoIHJlYWN0LXN0cmlwZS1qcyB2ZXJzaW9uIHRvIHN0cmlwZS5qcyBpbnN0YW5jZVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0ZXJXaXRoU3RyaXBlSnMoY3R4LnN0cmlwZSk7XG4gIH0sIFtjdHguc3RyaXBlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbGVtZW50c0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENhcnRFbGVtZW50Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBjYXJ0OiBjYXJ0LFxuICAgICAgc2V0Q2FydDogc2V0Q2FydCxcbiAgICAgIGNhcnRTdGF0ZTogY2FydFN0YXRlLFxuICAgICAgc2V0Q2FydFN0YXRlOiBzZXRDYXJ0U3RhdGVcbiAgICB9XG4gIH0sIGNoaWxkcmVuKSk7XG59O1xuRWxlbWVudHMucHJvcFR5cGVzID0ge1xuICBzdHJpcGU6IFByb3BUeXBlcy5hbnksXG4gIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3Rcbn07XG52YXIgdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UgPSBmdW5jdGlvbiB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlTWVzc2FnZSkge1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChFbGVtZW50c0NvbnRleHQpO1xuICByZXR1cm4gcGFyc2VFbGVtZW50c0NvbnRleHQoY3R4LCB1c2VDYXNlTWVzc2FnZSk7XG59O1xudmFyIERVTU1ZX0NBUlRfRUxFTUVOVF9DT05URVhUID0ge1xuICBjYXJ0OiBudWxsLFxuICBjYXJ0U3RhdGU6IG51bGwsXG4gIHNldENhcnQ6IGZ1bmN0aW9uIHNldENhcnQoKSB7fSxcbiAgc2V0Q2FydFN0YXRlOiBmdW5jdGlvbiBzZXRDYXJ0U3RhdGUoKSB7fVxufTtcbnZhciB1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZSA9IGZ1bmN0aW9uIHVzZUNhcnRFbGVtZW50Q29udGV4dFdpdGhVc2VDYXNlKHVzZUNhc2VNZXNzYWdlKSB7XG4gIHZhciBpc0luQ3VzdG9tQ2hlY2tvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChDYXJ0RWxlbWVudENvbnRleHQpO1xuXG4gIGlmIChpc0luQ3VzdG9tQ2hlY2tvdXQpIHtcbiAgICByZXR1cm4gRFVNTVlfQ0FSVF9FTEVNRU5UX0NPTlRFWFQ7XG4gIH1cblxuICByZXR1cm4gcGFyc2VDYXJ0RWxlbWVudENvbnRleHQoY3R4LCB1c2VDYXNlTWVzc2FnZSk7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjdXNlZWxlbWVudHMtaG9va1xuICovXG5cbnZhciB1c2VFbGVtZW50cyA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzKCkge1xuICB2YXIgX3VzZUVsZW1lbnRzQ29udGV4dFdpID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZUVsZW1lbnRzKCknKSxcbiAgICAgIGVsZW1lbnRzID0gX3VzZUVsZW1lbnRzQ29udGV4dFdpLmVsZW1lbnRzO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3BheW1lbnRzL2NoZWNrb3V0L2NhcnQtZWxlbWVudFxuICovXG5cbnZhciB1c2VDYXJ0RWxlbWVudCA9IGZ1bmN0aW9uIHVzZUNhcnRFbGVtZW50KCkge1xuICB2YXIgX3VzZUNhcnRFbGVtZW50Q29udGV4ID0gdXNlQ2FydEVsZW1lbnRDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZUNhcnRFbGVtZW50KCknKSxcbiAgICAgIGNhcnQgPSBfdXNlQ2FydEVsZW1lbnRDb250ZXguY2FydDtcblxuICByZXR1cm4gY2FydDtcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3BheW1lbnRzL2NoZWNrb3V0L2NhcnQtZWxlbWVudFxuICovXG5cbnZhciB1c2VDYXJ0RWxlbWVudFN0YXRlID0gZnVuY3Rpb24gdXNlQ2FydEVsZW1lbnRTdGF0ZSgpIHtcbiAgdmFyIF91c2VDYXJ0RWxlbWVudENvbnRleDIgPSB1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZSgnY2FsbHMgdXNlQ2FydEVsZW1lbnRTdGF0ZSgpJyksXG4gICAgICBjYXJ0U3RhdGUgPSBfdXNlQ2FydEVsZW1lbnRDb250ZXgyLmNhcnRTdGF0ZTtcblxuICByZXR1cm4gY2FydFN0YXRlO1xufTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLWNvbnN1bWVyXG4gKi9cblxudmFyIEVsZW1lbnRzQ29uc3VtZXIgPSBmdW5jdGlvbiBFbGVtZW50c0NvbnN1bWVyKF9yZWYyKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuO1xuICB2YXIgY3R4ID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoJ21vdW50cyA8RWxlbWVudHNDb25zdW1lcj4nKTsgLy8gQXNzZXJ0IHRvIHNhdGlzZnkgdGhlIGJ1c3RlZCBSZWFjdC5GQyByZXR1cm4gdHlwZSAoaXQgc2hvdWxkIGJlIFJlYWN0Tm9kZSlcblxuICByZXR1cm4gY2hpbGRyZW4oY3R4KTtcbn07XG5FbGVtZW50c0NvbnN1bWVyLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn07XG5cbnZhciB1c2VBdHRhY2hFdmVudCA9IGZ1bmN0aW9uIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsIGV2ZW50LCBjYikge1xuICB2YXIgY2JEZWZpbmVkID0gISFjYjtcbiAgdmFyIGNiUmVmID0gUmVhY3QudXNlUmVmKGNiKTsgLy8gSW4gbWFueSBpbnRlZ3JhdGlvbnMgdGhlIGNhbGxiYWNrIHByb3AgY2hhbmdlcyBvbiBlYWNoIHJlbmRlci5cbiAgLy8gVXNpbmcgYSByZWYgc2F2ZXMgdXMgZnJvbSBjYWxsaW5nIGVsZW1lbnQub24vLm9mZiBldmVyeSByZW5kZXIuXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBjYlJlZi5jdXJyZW50ID0gY2I7XG4gIH0sIFtjYl0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2JEZWZpbmVkIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgfVxuXG4gICAgdmFyIGRlY29yYXRlZENiID0gZnVuY3Rpb24gZGVjb3JhdGVkQ2IoKSB7XG4gICAgICBpZiAoY2JSZWYuY3VycmVudCkge1xuICAgICAgICBjYlJlZi5jdXJyZW50LmFwcGx5KGNiUmVmLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVtZW50Lm9uKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQub2ZmKGV2ZW50LCBkZWNvcmF0ZWRDYik7XG4gICAgfTtcbiAgfSwgW2NiRGVmaW5lZCwgZXZlbnQsIGVsZW1lbnQsIGNiUmVmXSk7XG59O1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wib25cIiwgXCJzZXNzaW9uXCJdO1xudmFyIEN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0N1c3RvbUNoZWNrb3V0U2RrQ29udGV4dCc7XG52YXIgcGFyc2VDdXN0b21DaGVja291dFNka0NvbnRleHQgPSBmdW5jdGlvbiBwYXJzZUN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dChjdHgsIHVzZUNhc2UpIHtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBDdXN0b21DaGVja291dFByb3ZpZGVyIGNvbnRleHQ7IFlvdSBuZWVkIHRvIHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBcIi5jb25jYXQodXNlQ2FzZSwgXCIgaW4gYW4gPEN1c3RvbUNoZWNrb3V0UHJvdmlkZXI+IHByb3ZpZGVyLlwiKSk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcbnZhciBDdXN0b21DaGVja291dENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkN1c3RvbUNoZWNrb3V0Q29udGV4dC5kaXNwbGF5TmFtZSA9ICdDdXN0b21DaGVja291dENvbnRleHQnO1xudmFyIGV4dHJhY3RDdXN0b21DaGVja291dENvbnRleHRWYWx1ZSA9IGZ1bmN0aW9uIGV4dHJhY3RDdXN0b21DaGVja291dENvbnRleHRWYWx1ZShjdXN0b21DaGVja291dFNkaywgc2Vzc2lvblN0YXRlKSB7XG4gIGlmICghY3VzdG9tQ2hlY2tvdXRTZGspIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBfb24gPSBjdXN0b21DaGVja291dFNkay5vbixcbiAgICAgIF9zZXNzaW9uID0gY3VzdG9tQ2hlY2tvdXRTZGsuc2Vzc2lvbixcbiAgICAgIGFjdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoY3VzdG9tQ2hlY2tvdXRTZGssIF9leGNsdWRlZCk7XG5cbiAgaWYgKCFzZXNzaW9uU3RhdGUpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGFjdGlvbnMpLCBjdXN0b21DaGVja291dFNkay5zZXNzaW9uKCkpO1xuICB9XG5cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBhY3Rpb25zKSwgc2Vzc2lvblN0YXRlKTtcbn07XG52YXIgSU5WQUxJRF9TVFJJUEVfRVJST1IkMSA9ICdJbnZhbGlkIHByb3AgYHN0cmlwZWAgc3VwcGxpZWQgdG8gYEN1c3RvbUNoZWNrb3V0UHJvdmlkZXJgLiBXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBsb2FkU3RyaXBlYCB1dGlsaXR5IGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYC4gU2VlIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm9wcy1zdHJpcGUgZm9yIGRldGFpbHMuJztcbnZhciBDdXN0b21DaGVja291dFByb3ZpZGVyID0gZnVuY3Rpb24gQ3VzdG9tQ2hlY2tvdXRQcm92aWRlcihfcmVmKSB7XG4gIHZhciByYXdTdHJpcGVQcm9wID0gX3JlZi5zdHJpcGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgcGFyc2VkID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlU3RyaXBlUHJvcChyYXdTdHJpcGVQcm9wLCBJTlZBTElEX1NUUklQRV9FUlJPUiQxKTtcbiAgfSwgW3Jhd1N0cmlwZVByb3BdKTsgLy8gU3RhdGUgdXNlZCB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyIHdoZW4gc2RrLnNlc3Npb24gaXMgdXBkYXRlZFxuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShudWxsKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgc2Vzc2lvbiA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRTZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyaXBlOiBwYXJzZWQudGFnID09PSAnc3luYycgPyBwYXJzZWQuc3RyaXBlIDogbnVsbCxcbiAgICAgIGN1c3RvbUNoZWNrb3V0U2RrOiBudWxsXG4gICAgfTtcbiAgfSksXG4gICAgICBfUmVhY3QkdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlMywgMiksXG4gICAgICBjdHggPSBfUmVhY3QkdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0Q29udGV4dCA9IF9SZWFjdCR1c2VTdGF0ZTRbMV07XG5cbiAgdmFyIHNhZmVTZXRDb250ZXh0ID0gZnVuY3Rpb24gc2FmZVNldENvbnRleHQoc3RyaXBlLCBjdXN0b21DaGVja291dFNkaykge1xuICAgIHNldENvbnRleHQoZnVuY3Rpb24gKGN0eCkge1xuICAgICAgaWYgKGN0eC5zdHJpcGUgJiYgY3R4LmN1c3RvbUNoZWNrb3V0U2RrKSB7XG4gICAgICAgIHJldHVybiBjdHg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmlwZTogc3RyaXBlLFxuICAgICAgICBjdXN0b21DaGVja291dFNkazogY3VzdG9tQ2hlY2tvdXRTZGtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07IC8vIFJlZiB1c2VkIHRvIGF2b2lkIGNhbGxpbmcgaW5pdEN1c3RvbUNoZWNrb3V0IG11bHRpcGxlIHRpbWVzIHdoZW4gb3B0aW9ucyBjaGFuZ2VzXG5cblxuICB2YXIgaW5pdEN1c3RvbUNoZWNrb3V0Q2FsbGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNNb3VudGVkID0gdHJ1ZTtcblxuICAgIGlmIChwYXJzZWQudGFnID09PSAnYXN5bmMnICYmICFjdHguc3RyaXBlKSB7XG4gICAgICBwYXJzZWQuc3RyaXBlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdHJpcGUpIHtcbiAgICAgICAgaWYgKHN0cmlwZSAmJiBpc01vdW50ZWQgJiYgIWluaXRDdXN0b21DaGVja291dENhbGxlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgLy8gT25seSB1cGRhdGUgY29udGV4dCBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWRcbiAgICAgICAgICAvLyBhbmQgc3RyaXBlIGlzIG5vdCBudWxsLiBXZSBhbGxvdyBzdHJpcGUgdG8gYmUgbnVsbCB0byBtYWtlXG4gICAgICAgICAgLy8gaGFuZGxpbmcgU1NSIGVhc2llci5cbiAgICAgICAgICBpbml0Q3VzdG9tQ2hlY2tvdXRDYWxsZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgc3RyaXBlLmluaXRDdXN0b21DaGVja291dChvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChjdXN0b21DaGVja291dFNkaykge1xuICAgICAgICAgICAgaWYgKGN1c3RvbUNoZWNrb3V0U2RrKSB7XG4gICAgICAgICAgICAgIHNhZmVTZXRDb250ZXh0KHN0cmlwZSwgY3VzdG9tQ2hlY2tvdXRTZGspO1xuICAgICAgICAgICAgICBjdXN0b21DaGVja291dFNkay5vbignY2hhbmdlJywgc2V0U2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gJ3N5bmMnICYmIHBhcnNlZC5zdHJpcGUgJiYgIWluaXRDdXN0b21DaGVja291dENhbGxlZFJlZi5jdXJyZW50KSB7XG4gICAgICBpbml0Q3VzdG9tQ2hlY2tvdXRDYWxsZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBwYXJzZWQuc3RyaXBlLmluaXRDdXN0b21DaGVja291dChvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChjdXN0b21DaGVja291dFNkaykge1xuICAgICAgICBpZiAoY3VzdG9tQ2hlY2tvdXRTZGspIHtcbiAgICAgICAgICBzYWZlU2V0Q29udGV4dChwYXJzZWQuc3RyaXBlLCBjdXN0b21DaGVja291dFNkayk7XG4gICAgICAgICAgY3VzdG9tQ2hlY2tvdXRTZGsub24oJ2NoYW5nZScsIHNldFNlc3Npb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3BhcnNlZCwgY3R4LCBvcHRpb25zLCBzZXRTZXNzaW9uXSk7IC8vIFdhcm4gb24gY2hhbmdlcyB0byBzdHJpcGUgcHJvcFxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBDdXN0b21DaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgYHN0cmlwZWAgcHJvcCBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZTdHJpcGUsIHJhd1N0cmlwZVByb3BdKTsgLy8gQXBwbHkgdXBkYXRlcyB0byBlbGVtZW50cyB3aGVuIG9wdGlvbnMgcHJvcCBoYXMgcmVsZXZhbnQgY2hhbmdlc1xuXG4gIHZhciBwcmV2T3B0aW9ucyA9IHVzZVByZXZpb3VzKG9wdGlvbnMpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcHJldk9wdGlvbnMkZWxlbWVudHMsIF9vcHRpb25zJGVsZW1lbnRzT3B0aTtcblxuICAgIGlmICghY3R4LmN1c3RvbUNoZWNrb3V0U2RrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2xpZW50U2VjcmV0ICYmICFpc1Vua25vd25PYmplY3QocHJldk9wdGlvbnMpICYmICFpc0VxdWFsKG9wdGlvbnMuY2xpZW50U2VjcmV0LCBwcmV2T3B0aW9ucy5jbGllbnRTZWNyZXQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlOiBvcHRpb25zLmNsaWVudF9zZWNyZXQgaXMgbm90IGEgbXV0YWJsZSBwcm9wZXJ0eS4nKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNBcHBlYXJhbmNlID0gcHJldk9wdGlvbnMgPT09IG51bGwgfHwgcHJldk9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfcHJldk9wdGlvbnMkZWxlbWVudHMgPSBwcmV2T3B0aW9ucy5lbGVtZW50c09wdGlvbnMpID09PSBudWxsIHx8IF9wcmV2T3B0aW9ucyRlbGVtZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXZPcHRpb25zJGVsZW1lbnRzLmFwcGVhcmFuY2U7XG4gICAgdmFyIGN1cnJlbnRBcHBlYXJhbmNlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdGlvbnMkZWxlbWVudHNPcHRpID0gb3B0aW9ucy5lbGVtZW50c09wdGlvbnMpID09PSBudWxsIHx8IF9vcHRpb25zJGVsZW1lbnRzT3B0aSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZWxlbWVudHNPcHRpLmFwcGVhcmFuY2U7XG5cbiAgICBpZiAoY3VycmVudEFwcGVhcmFuY2UgJiYgIWlzRXF1YWwoY3VycmVudEFwcGVhcmFuY2UsIHByZXZpb3VzQXBwZWFyYW5jZSkpIHtcbiAgICAgIGN0eC5jdXN0b21DaGVja291dFNkay5jaGFuZ2VBcHBlYXJhbmNlKGN1cnJlbnRBcHBlYXJhbmNlKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBwcmV2T3B0aW9ucywgY3R4LmN1c3RvbUNoZWNrb3V0U2RrXSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGN0eC5zdHJpcGUpO1xuICB9LCBbY3R4LnN0cmlwZV0pO1xuICB2YXIgY3VzdG9tQ2hlY2tvdXRDb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXh0cmFjdEN1c3RvbUNoZWNrb3V0Q29udGV4dFZhbHVlKGN0eC5jdXN0b21DaGVja291dFNkaywgc2Vzc2lvbik7XG4gIH0sIFtjdHguY3VzdG9tQ2hlY2tvdXRTZGssIHNlc3Npb25dKTtcblxuICBpZiAoIWN0eC5jdXN0b21DaGVja291dFNkaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjdHhcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tQ2hlY2tvdXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN1c3RvbUNoZWNrb3V0Q29udGV4dFZhbHVlXG4gIH0sIGNoaWxkcmVuKSk7XG59O1xuQ3VzdG9tQ2hlY2tvdXRQcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIHN0cmlwZTogUHJvcFR5cGVzLmFueSxcbiAgb3B0aW9uczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjbGllbnRTZWNyZXQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBlbGVtZW50c09wdGlvbnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufTtcbnZhciB1c2VDdXN0b21DaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSA9IGZ1bmN0aW9uIHVzZUN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKHVzZUNhc2VTdHJpbmcpIHtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0KTtcbiAgcmV0dXJuIHBhcnNlQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0KGN0eCwgdXNlQ2FzZVN0cmluZyk7XG59O1xudmFyIHVzZUVsZW1lbnRzT3JDdXN0b21DaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzT3JDdXN0b21DaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlU3RyaW5nKSB7XG4gIHZhciBjdXN0b21DaGVja291dFNka0NvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dCk7XG4gIHZhciBlbGVtZW50c0NvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEVsZW1lbnRzQ29udGV4dCk7XG5cbiAgaWYgKGN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dCAmJiBlbGVtZW50c0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBcIi5jb25jYXQodXNlQ2FzZVN0cmluZywgXCIgaW4gYm90aCA8Q3VzdG9tQ2hlY2tvdXRQcm92aWRlcj4gYW5kIDxFbGVtZW50cz4gcHJvdmlkZXJzLlwiKSk7XG4gIH1cblxuICBpZiAoY3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0KGN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dCwgdXNlQ2FzZVN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VFbGVtZW50c0NvbnRleHQoZWxlbWVudHNDb250ZXh0LCB1c2VDYXNlU3RyaW5nKTtcbn07XG52YXIgdXNlQ3VzdG9tQ2hlY2tvdXQgPSBmdW5jdGlvbiB1c2VDdXN0b21DaGVja291dCgpIHtcbiAgLy8gZW5zdXJlIGl0J3MgaW4gQ3VzdG9tQ2hlY2tvdXRQcm92aWRlclxuICB1c2VDdXN0b21DaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSgnY2FsbHMgdXNlQ3VzdG9tQ2hlY2tvdXQoKScpO1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChDdXN0b21DaGVja291dENvbnRleHQpO1xuXG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBDdXN0b21DaGVja291dCBDb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgY2FsbHMgdXNlQ3VzdG9tQ2hlY2tvdXQoKSBpbiBhbiA8Q3VzdG9tQ2hlY2tvdXRQcm92aWRlcj4gcHJvdmlkZXIuJyk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcblxudmFyIGNhcGl0YWxpemVkID0gZnVuY3Rpb24gY2FwaXRhbGl6ZWQoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59O1xuXG52YXIgY3JlYXRlRWxlbWVudENvbXBvbmVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRDb21wb25lbnQodHlwZSwgaXNTZXJ2ZXIpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gXCJcIi5jb25jYXQoY2FwaXRhbGl6ZWQodHlwZSksIFwiRWxlbWVudFwiKTtcblxuICB2YXIgQ2xpZW50RWxlbWVudCA9IGZ1bmN0aW9uIENsaWVudEVsZW1lbnQoX3JlZikge1xuICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zLFxuICAgICAgICBvbkJsdXIgPSBfcmVmLm9uQmx1cixcbiAgICAgICAgb25Gb2N1cyA9IF9yZWYub25Gb2N1cyxcbiAgICAgICAgb25SZWFkeSA9IF9yZWYub25SZWFkeSxcbiAgICAgICAgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlLFxuICAgICAgICBvbkVzY2FwZSA9IF9yZWYub25Fc2NhcGUsXG4gICAgICAgIG9uQ2xpY2sgPSBfcmVmLm9uQ2xpY2ssXG4gICAgICAgIG9uTG9hZEVycm9yID0gX3JlZi5vbkxvYWRFcnJvcixcbiAgICAgICAgb25Mb2FkZXJTdGFydCA9IF9yZWYub25Mb2FkZXJTdGFydCxcbiAgICAgICAgb25OZXR3b3Jrc0NoYW5nZSA9IF9yZWYub25OZXR3b3Jrc0NoYW5nZSxcbiAgICAgICAgb25DaGVja291dCA9IF9yZWYub25DaGVja291dCxcbiAgICAgICAgb25MaW5lSXRlbUNsaWNrID0gX3JlZi5vbkxpbmVJdGVtQ2xpY2ssXG4gICAgICAgIG9uQ29uZmlybSA9IF9yZWYub25Db25maXJtLFxuICAgICAgICBvbkNhbmNlbCA9IF9yZWYub25DYW5jZWwsXG4gICAgICAgIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlID0gX3JlZi5vblNoaXBwaW5nQWRkcmVzc0NoYW5nZSxcbiAgICAgICAgb25TaGlwcGluZ1JhdGVDaGFuZ2UgPSBfcmVmLm9uU2hpcHBpbmdSYXRlQ2hhbmdlO1xuICAgIHZhciBjdHggPSB1c2VFbGVtZW50c09yQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpKTtcbiAgICB2YXIgZWxlbWVudHMgPSAnZWxlbWVudHMnIGluIGN0eCA/IGN0eC5lbGVtZW50cyA6IG51bGw7XG4gICAgdmFyIGN1c3RvbUNoZWNrb3V0U2RrID0gJ2N1c3RvbUNoZWNrb3V0U2RrJyBpbiBjdHggPyBjdHguY3VzdG9tQ2hlY2tvdXRTZGsgOiBudWxsO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgICAgZWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICAgIHNldEVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gICAgdmFyIGVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIGRvbU5vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7XG5cbiAgICB2YXIgX3VzZUNhcnRFbGVtZW50Q29udGV4ID0gdXNlQ2FydEVsZW1lbnRDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpLCAnY3VzdG9tQ2hlY2tvdXRTZGsnIGluIGN0eCksXG4gICAgICAgIHNldENhcnQgPSBfdXNlQ2FydEVsZW1lbnRDb250ZXguc2V0Q2FydCxcbiAgICAgICAgc2V0Q2FydFN0YXRlID0gX3VzZUNhcnRFbGVtZW50Q29udGV4LnNldENhcnRTdGF0ZTsgLy8gRm9yIGV2ZXJ5IGV2ZW50IHdoZXJlIHRoZSBtZXJjaGFudCBwcm92aWRlcyBhIGNhbGxiYWNrLCBjYWxsIGVsZW1lbnQub25cbiAgICAvLyB3aXRoIHRoYXQgY2FsbGJhY2suIElmIHRoZSBtZXJjaGFudCBldmVyIGNoYW5nZXMgdGhlIGNhbGxiYWNrLCByZW1vdmVzXG4gICAgLy8gdGhlIG9sZCBjYWxsYmFjayB3aXRoIGVsZW1lbnQub2ZmIGFuZCB0aGVuIGNhbGwgZWxlbWVudC5vbiB3aXRoIHRoZSBuZXcgb25lLlxuXG5cbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnYmx1cicsIG9uQmx1cik7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2ZvY3VzJywgb25Gb2N1cyk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2VzY2FwZScsIG9uRXNjYXBlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2xpY2snLCBvbkNsaWNrKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnbG9hZGVycm9yJywgb25Mb2FkRXJyb3IpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsb2FkZXJzdGFydCcsIG9uTG9hZGVyU3RhcnQpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICduZXR3b3Jrc2NoYW5nZScsIG9uTmV0d29ya3NDaGFuZ2UpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsaW5laXRlbWNsaWNrJywgb25MaW5lSXRlbUNsaWNrKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY29uZmlybScsIG9uQ29uZmlybSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NhbmNlbCcsIG9uQ2FuY2VsKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnc2hpcHBpbmdhZGRyZXNzY2hhbmdlJywgb25TaGlwcGluZ0FkZHJlc3NDaGFuZ2UpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdzaGlwcGluZ3JhdGVjaGFuZ2UnLCBvblNoaXBwaW5nUmF0ZUNoYW5nZSk7XG4gICAgdmFyIHJlYWR5Q2FsbGJhY2s7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NhcnQnKSB7XG4gICAgICByZWFkeUNhbGxiYWNrID0gZnVuY3Rpb24gcmVhZHlDYWxsYmFjayhldmVudCkge1xuICAgICAgICBzZXRDYXJ0U3RhdGUoZXZlbnQpO1xuICAgICAgICBvblJlYWR5ICYmIG9uUmVhZHkoZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9uUmVhZHkpIHtcbiAgICAgIGlmICh0eXBlID09PSAnZXhwcmVzc0NoZWNrb3V0Jykge1xuICAgICAgICAvLyBQYXNzZXMgdGhyb3VnaCB0aGUgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIHZpc2libGUgUE0gdHlwZXNcbiAgICAgICAgcmVhZHlDYWxsYmFjayA9IG9uUmVhZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb3RoZXIgRWxlbWVudHMsIHBhc3MgdGhyb3VnaCB0aGUgRWxlbWVudCBpdHNlbGYuXG4gICAgICAgIHJlYWR5Q2FsbGJhY2sgPSBmdW5jdGlvbiByZWFkeUNhbGxiYWNrKCkge1xuICAgICAgICAgIG9uUmVhZHkoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3JlYWR5JywgcmVhZHlDYWxsYmFjayk7XG4gICAgdmFyIGNoYW5nZUNhbGxiYWNrID0gdHlwZSA9PT0gJ2NhcnQnID8gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzZXRDYXJ0U3RhdGUoZXZlbnQpO1xuICAgICAgb25DaGFuZ2UgJiYgb25DaGFuZ2UoZXZlbnQpO1xuICAgIH0gOiBvbkNoYW5nZTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2hhbmdlJywgY2hhbmdlQ2FsbGJhY2spO1xuICAgIHZhciBjaGVja291dENhbGxiYWNrID0gdHlwZSA9PT0gJ2NhcnQnID8gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBzZXRDYXJ0U3RhdGUoZXZlbnQpO1xuICAgICAgb25DaGVja291dCAmJiBvbkNoZWNrb3V0KGV2ZW50KTtcbiAgICB9IDogb25DaGVja291dDtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnY2hlY2tvdXQnLCBjaGVja291dENhbGxiYWNrKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCA9PT0gbnVsbCAmJiBkb21Ob2RlLmN1cnJlbnQgIT09IG51bGwgJiYgKGVsZW1lbnRzIHx8IGN1c3RvbUNoZWNrb3V0U2RrKSkge1xuICAgICAgICB2YXIgbmV3RWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGN1c3RvbUNoZWNrb3V0U2RrKSB7XG4gICAgICAgICAgbmV3RWxlbWVudCA9IGN1c3RvbUNoZWNrb3V0U2RrLmNyZWF0ZUVsZW1lbnQodHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICBuZXdFbGVtZW50ID0gZWxlbWVudHMuY3JlYXRlKHR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjYXJ0JyAmJiBzZXRDYXJ0KSB7XG4gICAgICAgICAgLy8gd2Uga25vdyB0aGF0IGVsZW1lbnRzLmNyZWF0ZSByZXR1cm4gdmFsdWUgbXVzdCBiZSBvZiB0eXBlIFN0cmlwZUNhcnRFbGVtZW50IGlmIHR5cGUgaXMgJ2NhcnQnLFxuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gY2FzdCBiZWNhdXNlIHR5cGVzY3JpcHQgaXMgbm90IGFibGUgdG8gaW5mZXIgd2hpY2ggb3ZlcmxvYWRlZCBtZXRob2QgaXMgdXNlZCBiYXNlZCBvZmYgcGFyYW0gdHlwZVxuICAgICAgICAgIHNldENhcnQobmV3RWxlbWVudCk7XG4gICAgICAgIH0gLy8gU3RvcmUgZWxlbWVudCBpbiBhIHJlZiB0byBlbnN1cmUgaXQncyBfaW1tZWRpYXRlbHlfIGF2YWlsYWJsZSBpbiBjbGVhbnVwIGhvb2tzIGluIFN0cmljdE1vZGVcblxuXG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG5ld0VsZW1lbnQ7IC8vIFN0b3JlIGVsZW1lbnQgaW4gc3RhdGUgdG8gZmFjaWxpdGF0ZSBldmVudCBsaXN0ZW5lciBhdHRhY2htZW50XG5cbiAgICAgICAgc2V0RWxlbWVudChuZXdFbGVtZW50KTtcblxuICAgICAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgICAgIG5ld0VsZW1lbnQubW91bnQoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtlbGVtZW50cywgY3VzdG9tQ2hlY2tvdXRTZGssIG9wdGlvbnMsIHNldENhcnRdKTtcbiAgICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlcyA9IGV4dHJhY3RBbGxvd2VkT3B0aW9uc1VwZGF0ZXMob3B0aW9ucywgcHJldk9wdGlvbnMsIFsncGF5bWVudFJlcXVlc3QnXSk7XG5cbiAgICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC51cGRhdGUodXBkYXRlcyk7XG4gICAgICB9XG4gICAgfSwgW29wdGlvbnMsIHByZXZPcHRpb25zXSk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlbGVtZW50UmVmLmN1cnJlbnQgJiYgdHlwZW9mIGVsZW1lbnRSZWYuY3VycmVudC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gRG8gbm90aGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgcmVmOiBkb21Ob2RlXG4gICAgfSk7XG4gIH07IC8vIE9ubHkgcmVuZGVyIHRoZSBFbGVtZW50IHdyYXBwZXIgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG5cblxuICB2YXIgU2VydmVyRWxlbWVudCA9IGZ1bmN0aW9uIFNlcnZlckVsZW1lbnQocHJvcHMpIHtcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHdlIGFyZSBpbiB0aGUgcmlnaHQgY29udGV4dCBieSBjYWxsaW5nIHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlLlxuICAgIHZhciBjdHggPSB1c2VFbGVtZW50c09yQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpKTtcbiAgICB1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIiksICdjdXN0b21DaGVja291dFNkaycgaW4gY3R4KTtcbiAgICB2YXIgaWQgPSBwcm9wcy5pZCxcbiAgICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBFbGVtZW50ID0gaXNTZXJ2ZXIgPyBTZXJ2ZXJFbGVtZW50IDogQ2xpZW50RWxlbWVudDtcbiAgRWxlbWVudC5wcm9wVHlwZXMgPSB7XG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVhZHk6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRXNjYXBlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRFcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Mb2FkZXJTdGFydDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25OZXR3b3Jrc0NoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DaGVja291dDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25MaW5lSXRlbUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNvbmZpcm06IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2FuY2VsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNoaXBwaW5nQWRkcmVzc0NoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TaGlwcGluZ1JhdGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcbiAgRWxlbWVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICBFbGVtZW50Ll9fZWxlbWVudFR5cGUgPSB0eXBlO1xuICByZXR1cm4gRWxlbWVudDtcbn07XG5cbnZhciBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG52YXIgRW1iZWRkZWRDaGVja291dENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0VtYmVkZGVkQ2hlY2tvdXRQcm92aWRlckNvbnRleHQnO1xudmFyIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0ID0gZnVuY3Rpb24gdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQoKSB7XG4gIHZhciBjdHggPSBSZWFjdC51c2VDb250ZXh0KEVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0KTtcblxuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcignPEVtYmVkZGVkQ2hlY2tvdXQ+IG11c3QgYmUgdXNlZCB3aXRoaW4gPEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcj4nKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xudmFyIElOVkFMSURfU1RSSVBFX0VSUk9SJDIgPSAnSW52YWxpZCBwcm9wIGBzdHJpcGVgIHN1cHBsaWVkIHRvIGBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXJgLiBXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBsb2FkU3RyaXBlYCB1dGlsaXR5IGZyb20gYEBzdHJpcGUvc3RyaXBlLWpzYC4gU2VlIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1wcm9wcy1zdHJpcGUgZm9yIGRldGFpbHMuJztcbnZhciBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIgPSBmdW5jdGlvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIHBhcnNlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZVN0cmlwZVByb3AocmF3U3RyaXBlUHJvcCwgSU5WQUxJRF9TVFJJUEVfRVJST1IkMik7XG4gIH0sIFtyYXdTdHJpcGVQcm9wXSk7XG4gIHZhciBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGxvYWRlZFN0cmlwZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGVtYmVkZGVkQ2hlY2tvdXQ6IG51bGxcbiAgfSksXG4gICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgIGN0eCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRDb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIC8vIERvbid0IHN1cHBvcnQgYW55IGN0eCB1cGRhdGVzIG9uY2UgZW1iZWRkZWRDaGVja291dCBvciBzdHJpcGUgaXMgc2V0LlxuICAgIGlmIChsb2FkZWRTdHJpcGUuY3VycmVudCB8fCBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0ID0gZnVuY3Rpb24gc2V0U3RyaXBlQW5kSW5pdEVtYmVkZGVkQ2hlY2tvdXQoc3RyaXBlKSB7XG4gICAgICBpZiAobG9hZGVkU3RyaXBlLmN1cnJlbnQgfHwgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCkgcmV0dXJuO1xuICAgICAgbG9hZGVkU3RyaXBlLmN1cnJlbnQgPSBzdHJpcGU7XG4gICAgICBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50ID0gbG9hZGVkU3RyaXBlLmN1cnJlbnQuaW5pdEVtYmVkZGVkQ2hlY2tvdXQob3B0aW9ucykudGhlbihmdW5jdGlvbiAoZW1iZWRkZWRDaGVja291dCkge1xuICAgICAgICBzZXRDb250ZXh0KHtcbiAgICAgICAgICBlbWJlZGRlZENoZWNrb3V0OiBlbWJlZGRlZENoZWNrb3V0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTsgLy8gRm9yIGFuIGFzeW5jIHN0cmlwZVByb21pc2UsIHN0b3JlIGl0IG9uY2UgcmVzb2x2ZWRcblxuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWxvYWRlZFN0cmlwZS5jdXJyZW50ICYmIG9wdGlvbnMuY2xpZW50U2VjcmV0KSB7XG4gICAgICBwYXJzZWQuc3RyaXBlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdHJpcGUpIHtcbiAgICAgICAgaWYgKHN0cmlwZSkge1xuICAgICAgICAgIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0KHN0cmlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gJ3N5bmMnICYmICFsb2FkZWRTdHJpcGUuY3VycmVudCAmJiBvcHRpb25zLmNsaWVudFNlY3JldCkge1xuICAgICAgLy8gT3IsIGhhbmRsZSBhIHN5bmMgc3RyaXBlIGluc3RhbmNlIGdvaW5nIGZyb20gbnVsbCAtPiBwb3B1bGF0ZWRcbiAgICAgIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0KHBhcnNlZC5zdHJpcGUpO1xuICAgIH1cbiAgfSwgW3BhcnNlZCwgb3B0aW9ucywgY3R4LCBsb2FkZWRTdHJpcGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjbGVhbnVwIG9uIHVubW91bnRcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSWYgZW1iZWRkZWQgY2hlY2tvdXQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQsIGRlc3Ryb3kgaXQuXG4gICAgICBpZiAoY3R4LmVtYmVkZGVkQ2hlY2tvdXQpIHtcbiAgICAgICAgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN0eC5lbWJlZGRlZENoZWNrb3V0LmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSBpZiAoZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudCkge1xuICAgICAgICAvLyBJZiBlbWJlZGRlZCBjaGVja291dCBpcyBzdGlsbCBpbml0aWFsaXppbmcsIGRlc3Ryb3kgaXQgb25jZVxuICAgICAgICAvLyBpdCdzIGRvbmUuIFRoaXMgY291bGQgYmUgY2F1c2VkIGJ5IHVubW91bnRpbmcgdmVyeSBxdWlja2x5XG4gICAgICAgIC8vIGFmdGVyIG1vdW50aW5nLlxuICAgICAgICBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGN0eC5lbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgICAgICBjdHguZW1iZWRkZWRDaGVja291dC5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY3R4LmVtYmVkZGVkQ2hlY2tvdXRdKTsgLy8gQXR0YWNoIHJlYWN0LXN0cmlwZS1qcyB2ZXJzaW9uIHRvIHN0cmlwZS5qcyBpbnN0YW5jZVxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVnaXN0ZXJXaXRoU3RyaXBlSnMobG9hZGVkU3RyaXBlKTtcbiAgfSwgW2xvYWRlZFN0cmlwZV0pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gc3RyaXBlIHByb3AuXG4gIC8vIFRoZSBzdHJpcGUgcHJvcCB2YWx1ZSBjYW4gb25seSBnbyBmcm9tIG51bGwgdG8gbm9uLW51bGwgb25jZSBhbmRcbiAgLy8gY2FuJ3QgYmUgY2hhbmdlZCBhZnRlciB0aGF0LlxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldlN0cmlwZSwgcmF3U3RyaXBlUHJvcF0pOyAvLyBXYXJuIG9uIGNoYW5nZXMgdG8gb3B0aW9ucy5cblxuICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldk9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IHVuc2V0IG9wdGlvbnMgYWZ0ZXIgc2V0dGluZyB0aGVtLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcmV2T3B0aW9ucy5jbGllbnRTZWNyZXQgIT0gbnVsbCAmJiBvcHRpb25zLmNsaWVudFNlY3JldCAhPT0gcHJldk9wdGlvbnMuY2xpZW50U2VjcmV0KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGNsaWVudCBzZWNyZXQgYWZ0ZXIgc2V0dGluZyBpdC4gVW5tb3VudCBhbmQgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGlmIChwcmV2T3B0aW9ucy5vbkNvbXBsZXRlICE9IG51bGwgJiYgb3B0aW9ucy5vbkNvbXBsZXRlICE9PSBwcmV2T3B0aW9ucy5vbkNvbXBsZXRlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIG9uQ29tcGxldGUgb3B0aW9uIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldk9wdGlvbnMsIG9wdGlvbnNdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eFxuICB9LCBjaGlsZHJlbik7XG59O1xuXG52YXIgRW1iZWRkZWRDaGVja291dENsaWVudEVsZW1lbnQgPSBmdW5jdGlvbiBFbWJlZGRlZENoZWNrb3V0Q2xpZW50RWxlbWVudChfcmVmKSB7XG4gIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZTtcblxuICB2YXIgX3VzZUVtYmVkZGVkQ2hlY2tvdXRDID0gdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQoKSxcbiAgICAgIGVtYmVkZGVkQ2hlY2tvdXQgPSBfdXNlRW1iZWRkZWRDaGVja291dEMuZW1iZWRkZWRDaGVja291dDtcblxuICB2YXIgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdmFyIGRvbU5vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc01vdW50ZWQuY3VycmVudCAmJiBlbWJlZGRlZENoZWNrb3V0ICYmIGRvbU5vZGUuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgZW1iZWRkZWRDaGVja291dC5tb3VudChkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0gLy8gQ2xlYW4gdXAgb24gdW5tb3VudFxuXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50ICYmIGVtYmVkZGVkQ2hlY2tvdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbWJlZGRlZENoZWNrb3V0LnVubW91bnQoKTtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9IGNhdGNoIChlKSB7Ly8gRG8gbm90aGluZy5cbiAgICAgICAgICAvLyBQYXJlbnQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGJlZm9yZSBjaGlsZCBlZmZlY3RzLCBzb1xuICAgICAgICAgIC8vIGluIGNhc2VzIHdoZXJlIGJvdGggdGhlIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciBhbmRcbiAgICAgICAgICAvLyB0aGUgRW1iZWRkZWRDaGVja291dCBjb21wb25lbnQgYXJlIHJlbW92ZWQgYXQgdGhlIHNhbWVcbiAgICAgICAgICAvLyB0aW1lLCB0aGUgZW1iZWRkZWRDaGVja291dCBpbnN0YW5jZSB3aWxsIGJlIGRlc3Ryb3llZCxcbiAgICAgICAgICAvLyB3aGljaCBjYXVzZXMgYW4gZXJyb3Igd2hlbiBjYWxsaW5nIHVubW91bnQuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW1iZWRkZWRDaGVja291dF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogZG9tTm9kZSxcbiAgICBpZDogaWQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSk7XG59OyAvLyBPbmx5IHJlbmRlciB0aGUgd3JhcHBlciBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cblxuXG52YXIgRW1iZWRkZWRDaGVja291dFNlcnZlckVsZW1lbnQgPSBmdW5jdGlvbiBFbWJlZGRlZENoZWNrb3V0U2VydmVyRWxlbWVudChfcmVmMikge1xuICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZTtcbiAgLy8gVmFsaWRhdGUgdGhhdCB3ZSBhcmUgaW4gdGhlIHJpZ2h0IGNvbnRleHQgYnkgY2FsbGluZyB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dC5cbiAgdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQoKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBpZDogaWQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSk7XG59O1xuXG52YXIgRW1iZWRkZWRDaGVja291dCA9IGlzU2VydmVyID8gRW1iZWRkZWRDaGVja291dFNlcnZlckVsZW1lbnQgOiBFbWJlZGRlZENoZWNrb3V0Q2xpZW50RWxlbWVudDtcblxuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjdXNlc3RyaXBlLWhvb2tcbiAqL1xuXG52YXIgdXNlU3RyaXBlID0gZnVuY3Rpb24gdXNlU3RyaXBlKCkge1xuICB2YXIgX3VzZUVsZW1lbnRzT3JDdXN0b21DID0gdXNlRWxlbWVudHNPckN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKCdjYWxscyB1c2VTdHJpcGUoKScpLFxuICAgICAgc3RyaXBlID0gX3VzZUVsZW1lbnRzT3JDdXN0b21DLnN0cmlwZTtcblxuICByZXR1cm4gc3RyaXBlO1xufTtcblxuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQXVCYW5rQWNjb3VudEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhdUJhbmtBY2NvdW50JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkTnVtYmVyRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmROdW1iZXInLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEV4cGlyeUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkRXhwaXJ5JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmRDdmNFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZEN2YycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBGcHhCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2ZweEJhbmsnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgSWJhbkVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdpYmFuJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIElkZWFsQmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdpZGVhbEJhbmsnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUDI0QmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwMjRCYW5rJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEVwc0JhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnZXBzQmFuaycsIGlzU2VydmVyKTtcbnZhciBQYXltZW50RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgRXhwcmVzc0NoZWNrb3V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2V4cHJlc3NDaGVja291dCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQYXltZW50UmVxdWVzdEJ1dHRvbkVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwYXltZW50UmVxdWVzdEJ1dHRvbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBMaW5rQXV0aGVudGljYXRpb25FbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnbGlua0F1dGhlbnRpY2F0aW9uJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEFkZHJlc3NFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnYWRkcmVzcycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIFVzZSBgQWRkcmVzc0VsZW1lbnRgIGluc3RlYWQuXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBTaGlwcGluZ0FkZHJlc3NFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnc2hpcHBpbmdBZGRyZXNzJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL2VsZW1lbnRzL2NhcnQtZWxlbWVudFxuICovXG5cbnZhciBDYXJ0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcnQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUGF5bWVudE1ldGhvZE1lc3NhZ2luZ0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdwYXltZW50TWV0aG9kTWVzc2FnaW5nJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEFmZmlybU1lc3NhZ2VFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnYWZmaXJtTWVzc2FnZScsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZnRlcnBheUNsZWFycGF5TWVzc2FnZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhZnRlcnBheUNsZWFycGF5TWVzc2FnZScsIGlzU2VydmVyKTtcblxuZXhwb3J0IHsgQWRkcmVzc0VsZW1lbnQsIEFmZmlybU1lc3NhZ2VFbGVtZW50LCBBZnRlcnBheUNsZWFycGF5TWVzc2FnZUVsZW1lbnQsIEF1QmFua0FjY291bnRFbGVtZW50LCBDYXJkQ3ZjRWxlbWVudCwgQ2FyZEVsZW1lbnQsIENhcmRFeHBpcnlFbGVtZW50LCBDYXJkTnVtYmVyRWxlbWVudCwgQ2FydEVsZW1lbnQsIEN1c3RvbUNoZWNrb3V0UHJvdmlkZXIsIEVsZW1lbnRzLCBFbGVtZW50c0NvbnN1bWVyLCBFbWJlZGRlZENoZWNrb3V0LCBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIsIEVwc0JhbmtFbGVtZW50LCBFeHByZXNzQ2hlY2tvdXRFbGVtZW50LCBGcHhCYW5rRWxlbWVudCwgSWJhbkVsZW1lbnQsIElkZWFsQmFua0VsZW1lbnQsIExpbmtBdXRoZW50aWNhdGlvbkVsZW1lbnQsIFAyNEJhbmtFbGVtZW50LCBQYXltZW50RWxlbWVudCwgUGF5bWVudE1ldGhvZE1lc3NhZ2luZ0VsZW1lbnQsIFBheW1lbnRSZXF1ZXN0QnV0dG9uRWxlbWVudCwgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCwgdXNlQ2FydEVsZW1lbnQsIHVzZUNhcnRFbGVtZW50U3RhdGUsIHVzZUN1c3RvbUNoZWNrb3V0LCB1c2VFbGVtZW50cywgdXNlU3RyaXBlIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJQcm9wVHlwZXMiLCJvd25LZXlzIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJmb3JFYWNoIiwia2V5IiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwiaW5kZXhPZiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJBcnJheSIsImlzQXJyYXkiLCJfaSIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsIm5leHQiLCJkb25lIiwiZXJyIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwiZnJvbSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiVHlwZUVycm9yIiwidXNlUHJldmlvdXMiLCJyZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiaXNVbmtub3duT2JqZWN0IiwicmF3IiwiaXNQcm9taXNlIiwidGhlbiIsImlzU3RyaXBlIiwiZWxlbWVudHMiLCJjcmVhdGVUb2tlbiIsImNyZWF0ZVBheW1lbnRNZXRob2QiLCJjb25maXJtQ2FyZFBheW1lbnQiLCJQTEFJTl9PQkpFQ1RfU1RSIiwiaXNFcXVhbCIsImxlZnQiLCJyaWdodCIsImxlZnRBcnJheSIsInJpZ2h0QXJyYXkiLCJsZWZ0UGxhaW5PYmplY3QiLCJyaWdodFBsYWluT2JqZWN0IiwibGVmdEtleXMiLCJyaWdodEtleXMiLCJrZXlTZXQiLCJhbGxLZXlzIiwibCIsInIiLCJwcmVkIiwiZXZlcnkiLCJleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzIiwib3B0aW9ucyIsInByZXZPcHRpb25zIiwiaW1tdXRhYmxlS2V5cyIsInJlZHVjZSIsIm5ld09wdGlvbnMiLCJpc1VwZGF0ZWQiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJ3YXJuIiwiY29uY2F0IiwiSU5WQUxJRF9TVFJJUEVfRVJST1IiLCJ2YWxpZGF0ZVN0cmlwZSIsIm1heWJlU3RyaXBlIiwiZXJyb3JNc2ciLCJ1bmRlZmluZWQiLCJFcnJvciIsInBhcnNlU3RyaXBlUHJvcCIsInRhZyIsInN0cmlwZVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc3VsdCIsInN0cmlwZSIsInJlZ2lzdGVyV2l0aFN0cmlwZUpzIiwiX3JlZ2lzdGVyV3JhcHBlciIsInJlZ2lzdGVyQXBwSW5mbyIsInZlcnNpb24iLCJ1cmwiLCJFbGVtZW50c0NvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZGlzcGxheU5hbWUiLCJwYXJzZUVsZW1lbnRzQ29udGV4dCIsImN0eCIsInVzZUNhc2UiLCJDYXJ0RWxlbWVudENvbnRleHQiLCJwYXJzZUNhcnRFbGVtZW50Q29udGV4dCIsIkVsZW1lbnRzIiwiX3JlZiIsInJhd1N0cmlwZVByb3AiLCJjaGlsZHJlbiIsInBhcnNlZCIsInVzZU1lbW8iLCJfUmVhY3QkdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl9SZWFjdCR1c2VTdGF0ZTIiLCJjYXJ0Iiwic2V0Q2FydCIsIl9SZWFjdCR1c2VTdGF0ZTMiLCJfUmVhY3QkdXNlU3RhdGU0IiwiY2FydFN0YXRlIiwic2V0Q2FydFN0YXRlIiwiX1JlYWN0JHVzZVN0YXRlNSIsIl9SZWFjdCR1c2VTdGF0ZTYiLCJzZXRDb250ZXh0IiwiaXNNb3VudGVkIiwic2FmZVNldENvbnRleHQiLCJwcmV2U3RyaXBlIiwidXBkYXRlcyIsInVwZGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInByb3BUeXBlcyIsImFueSIsInVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlIiwidXNlQ2FzZU1lc3NhZ2UiLCJ1c2VDb250ZXh0IiwiRFVNTVlfQ0FSVF9FTEVNRU5UX0NPTlRFWFQiLCJ1c2VDYXJ0RWxlbWVudENvbnRleHRXaXRoVXNlQ2FzZSIsImlzSW5DdXN0b21DaGVja291dCIsInVzZUVsZW1lbnRzIiwiX3VzZUVsZW1lbnRzQ29udGV4dFdpIiwidXNlQ2FydEVsZW1lbnQiLCJfdXNlQ2FydEVsZW1lbnRDb250ZXgiLCJ1c2VDYXJ0RWxlbWVudFN0YXRlIiwiX3VzZUNhcnRFbGVtZW50Q29udGV4MiIsIkVsZW1lbnRzQ29uc3VtZXIiLCJfcmVmMiIsImZ1bmMiLCJpc1JlcXVpcmVkIiwidXNlQXR0YWNoRXZlbnQiLCJlbGVtZW50IiwiZXZlbnQiLCJjYiIsImNiRGVmaW5lZCIsImNiUmVmIiwiZGVjb3JhdGVkQ2IiLCJvbiIsIm9mZiIsIl9leGNsdWRlZCIsIkN1c3RvbUNoZWNrb3V0U2RrQ29udGV4dCIsInBhcnNlQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0IiwiQ3VzdG9tQ2hlY2tvdXRDb250ZXh0IiwiZXh0cmFjdEN1c3RvbUNoZWNrb3V0Q29udGV4dFZhbHVlIiwiY3VzdG9tQ2hlY2tvdXRTZGsiLCJzZXNzaW9uU3RhdGUiLCJfb24iLCJfc2Vzc2lvbiIsInNlc3Npb24iLCJhY3Rpb25zIiwiSU5WQUxJRF9TVFJJUEVfRVJST1IkMSIsIkN1c3RvbUNoZWNrb3V0UHJvdmlkZXIiLCJzZXRTZXNzaW9uIiwiaW5pdEN1c3RvbUNoZWNrb3V0Q2FsbGVkUmVmIiwiaW5pdEN1c3RvbUNoZWNrb3V0IiwiX3ByZXZPcHRpb25zJGVsZW1lbnRzIiwiX29wdGlvbnMkZWxlbWVudHNPcHRpIiwiY2xpZW50U2VjcmV0IiwicHJldmlvdXNBcHBlYXJhbmNlIiwiZWxlbWVudHNPcHRpb25zIiwiYXBwZWFyYW5jZSIsImN1cnJlbnRBcHBlYXJhbmNlIiwiY2hhbmdlQXBwZWFyYW5jZSIsImN1c3RvbUNoZWNrb3V0Q29udGV4dFZhbHVlIiwic2hhcGUiLCJzdHJpbmciLCJ1c2VDdXN0b21DaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSIsInVzZUNhc2VTdHJpbmciLCJ1c2VFbGVtZW50c09yQ3VzdG9tQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UiLCJjdXN0b21DaGVja291dFNka0NvbnRleHQiLCJlbGVtZW50c0NvbnRleHQiLCJ1c2VDdXN0b21DaGVja291dCIsImNhcGl0YWxpemVkIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJjcmVhdGVFbGVtZW50Q29tcG9uZW50IiwidHlwZSIsImlzU2VydmVyIiwiQ2xpZW50RWxlbWVudCIsImlkIiwiY2xhc3NOYW1lIiwiX3JlZiRvcHRpb25zIiwib25CbHVyIiwib25Gb2N1cyIsIm9uUmVhZHkiLCJvbkNoYW5nZSIsIm9uRXNjYXBlIiwib25DbGljayIsIm9uTG9hZEVycm9yIiwib25Mb2FkZXJTdGFydCIsIm9uTmV0d29ya3NDaGFuZ2UiLCJvbkNoZWNrb3V0Iiwib25MaW5lSXRlbUNsaWNrIiwib25Db25maXJtIiwib25DYW5jZWwiLCJvblNoaXBwaW5nQWRkcmVzc0NoYW5nZSIsIm9uU2hpcHBpbmdSYXRlQ2hhbmdlIiwic2V0RWxlbWVudCIsImVsZW1lbnRSZWYiLCJkb21Ob2RlIiwicmVhZHlDYWxsYmFjayIsImNoYW5nZUNhbGxiYWNrIiwiY2hlY2tvdXRDYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsIm5ld0VsZW1lbnQiLCJjcmVhdGUiLCJtb3VudCIsImRlc3Ryb3kiLCJlcnJvciIsIlNlcnZlckVsZW1lbnQiLCJwcm9wcyIsIkVsZW1lbnQiLCJfX2VsZW1lbnRUeXBlIiwiRW1iZWRkZWRDaGVja291dENvbnRleHQiLCJ1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCIsIklOVkFMSURfU1RSSVBFX0VSUk9SJDIiLCJFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXIiLCJlbWJlZGRlZENoZWNrb3V0UHJvbWlzZSIsImxvYWRlZFN0cmlwZSIsImVtYmVkZGVkQ2hlY2tvdXQiLCJzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dCIsImluaXRFbWJlZGRlZENoZWNrb3V0Iiwib25Db21wbGV0ZSIsIkVtYmVkZGVkQ2hlY2tvdXRDbGllbnRFbGVtZW50IiwiX3VzZUVtYmVkZGVkQ2hlY2tvdXRDIiwidW5tb3VudCIsImUiLCJFbWJlZGRlZENoZWNrb3V0U2VydmVyRWxlbWVudCIsIkVtYmVkZGVkQ2hlY2tvdXQiLCJ1c2VTdHJpcGUiLCJfdXNlRWxlbWVudHNPckN1c3RvbUMiLCJBdUJhbmtBY2NvdW50RWxlbWVudCIsIkNhcmRFbGVtZW50IiwiQ2FyZE51bWJlckVsZW1lbnQiLCJDYXJkRXhwaXJ5RWxlbWVudCIsIkNhcmRDdmNFbGVtZW50IiwiRnB4QmFua0VsZW1lbnQiLCJJYmFuRWxlbWVudCIsIklkZWFsQmFua0VsZW1lbnQiLCJQMjRCYW5rRWxlbWVudCIsIkVwc0JhbmtFbGVtZW50IiwiUGF5bWVudEVsZW1lbnQiLCJFeHByZXNzQ2hlY2tvdXRFbGVtZW50IiwiUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50IiwiTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCIsIkFkZHJlc3NFbGVtZW50IiwiU2hpcHBpbmdBZGRyZXNzRWxlbWVudCIsIkNhcnRFbGVtZW50IiwiUGF5bWVudE1ldGhvZE1lc3NhZ2luZ0VsZW1lbnQiLCJBZmZpcm1NZXNzYWdlRWxlbWVudCIsIkFmdGVycGF5Q2xlYXJwYXlNZXNzYWdlRWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/dist/stripe.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/stripe.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadStripe: () => (/* binding */ loadStripe)\n/* harmony export */ });\nvar V3_URL = \"https://js.stripe.com/v3\";\nvar V3_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/v3\\/?(\\?.*)?$/;\nvar EXISTING_SCRIPT_MESSAGE = \"loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used\";\nvar findScript = function findScript() {\n    var scripts = document.querySelectorAll('script[src^=\"'.concat(V3_URL, '\"]'));\n    for(var i = 0; i < scripts.length; i++){\n        var script = scripts[i];\n        if (!V3_URL_REGEX.test(script.src)) {\n            continue;\n        }\n        return script;\n    }\n    return null;\n};\nvar injectScript = function injectScript(params) {\n    var queryString = params && !params.advancedFraudSignals ? \"?advancedFraudSignals=false\" : \"\";\n    var script = document.createElement(\"script\");\n    script.src = \"\".concat(V3_URL).concat(queryString);\n    var headOrBody = document.head || document.body;\n    if (!headOrBody) {\n        throw new Error(\"Expected document.body not to be null. Stripe.js requires a <body> element.\");\n    }\n    headOrBody.appendChild(script);\n    return script;\n};\nvar registerWrapper = function registerWrapper(stripe, startTime) {\n    if (!stripe || !stripe._registerWrapper) {\n        return;\n    }\n    stripe._registerWrapper({\n        name: \"stripe-js\",\n        version: \"2.4.0\",\n        startTime: startTime\n    });\n};\nvar stripePromise = null;\nvar onErrorListener = null;\nvar onLoadListener = null;\nvar onError = function onError(reject) {\n    return function() {\n        reject(new Error(\"Failed to load Stripe.js\"));\n    };\n};\nvar onLoad = function onLoad(resolve, reject) {\n    return function() {\n        if (window.Stripe) {\n            resolve(window.Stripe);\n        } else {\n            reject(new Error(\"Stripe.js not available\"));\n        }\n    };\n};\nvar loadScript = function loadScript(params) {\n    // Ensure that we only attempt to load Stripe.js at most once\n    if (stripePromise !== null) {\n        return stripePromise;\n    }\n    stripePromise = new Promise(function(resolve, reject) {\n        if (true) {\n            // Resolve to null when imported server side. This makes the module\n            // safe to import in an isomorphic code base.\n            resolve(null);\n            return;\n        }\n        if (window.Stripe && params) {\n            console.warn(EXISTING_SCRIPT_MESSAGE);\n        }\n        if (window.Stripe) {\n            resolve(window.Stripe);\n            return;\n        }\n        try {\n            var script = findScript();\n            if (script && params) {\n                console.warn(EXISTING_SCRIPT_MESSAGE);\n            } else if (!script) {\n                script = injectScript(params);\n            } else if (script && onLoadListener !== null && onErrorListener !== null) {\n                var _script$parentNode;\n                // remove event listeners\n                script.removeEventListener(\"load\", onLoadListener);\n                script.removeEventListener(\"error\", onErrorListener); // if script exists, but we are reloading due to an error,\n                // reload script to trigger 'load' event\n                (_script$parentNode = script.parentNode) === null || _script$parentNode === void 0 ? void 0 : _script$parentNode.removeChild(script);\n                script = injectScript(params);\n            }\n            onLoadListener = onLoad(resolve, reject);\n            onErrorListener = onError(reject);\n            script.addEventListener(\"load\", onLoadListener);\n            script.addEventListener(\"error\", onErrorListener);\n        } catch (error) {\n            reject(error);\n            return;\n        }\n    }); // Resets stripePromise on error\n    return stripePromise[\"catch\"](function(error) {\n        stripePromise = null;\n        return Promise.reject(error);\n    });\n};\nvar initStripe = function initStripe(maybeStripe, args, startTime) {\n    if (maybeStripe === null) {\n        return null;\n    }\n    var stripe = maybeStripe.apply(undefined, args);\n    registerWrapper(stripe, startTime);\n    return stripe;\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nvar stripePromise$1;\nvar loadCalled = false;\nvar getStripePromise = function getStripePromise() {\n    if (stripePromise$1) {\n        return stripePromise$1;\n    }\n    stripePromise$1 = loadScript(null)[\"catch\"](function(error) {\n        // clear cache on error\n        stripePromise$1 = null;\n        return Promise.reject(error);\n    });\n    return stripePromise$1;\n}; // Execute our own script injection after a tick to give users time to do their\n// own script injection.\nPromise.resolve().then(function() {\n    return getStripePromise();\n})[\"catch\"](function(error) {\n    if (!loadCalled) {\n        console.warn(error);\n    }\n});\nvar loadStripe = function loadStripe() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    loadCalled = true;\n    var startTime = Date.now(); // if previous attempts are unsuccessful, will re-load script\n    return getStripePromise().then(function(maybeStripe) {\n        return initStripe(maybeStripe, args, startTime);\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9zdHJpcGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxTQUFTO0FBQ2IsSUFBSUMsZUFBZTtBQUNuQixJQUFJQywwQkFBMEI7QUFDOUIsSUFBSUMsYUFBYSxTQUFTQTtJQUN4QixJQUFJQyxVQUFVQyxTQUFTQyxnQkFBZ0IsQ0FBQyxnQkFBaUJDLE1BQU0sQ0FBQ1AsUUFBUTtJQUV4RSxJQUFLLElBQUlRLElBQUksR0FBR0EsSUFBSUosUUFBUUssTUFBTSxFQUFFRCxJQUFLO1FBQ3ZDLElBQUlFLFNBQVNOLE9BQU8sQ0FBQ0ksRUFBRTtRQUV2QixJQUFJLENBQUNQLGFBQWFVLElBQUksQ0FBQ0QsT0FBT0UsR0FBRyxHQUFHO1lBQ2xDO1FBQ0Y7UUFFQSxPQUFPRjtJQUNUO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSUcsZUFBZSxTQUFTQSxhQUFhQyxNQUFNO0lBQzdDLElBQUlDLGNBQWNELFVBQVUsQ0FBQ0EsT0FBT0Usb0JBQW9CLEdBQUcsZ0NBQWdDO0lBQzNGLElBQUlOLFNBQVNMLFNBQVNZLGFBQWEsQ0FBQztJQUNwQ1AsT0FBT0UsR0FBRyxHQUFHLEdBQUdMLE1BQU0sQ0FBQ1AsUUFBUU8sTUFBTSxDQUFDUTtJQUN0QyxJQUFJRyxhQUFhYixTQUFTYyxJQUFJLElBQUlkLFNBQVNlLElBQUk7SUFFL0MsSUFBSSxDQUFDRixZQUFZO1FBQ2YsTUFBTSxJQUFJRyxNQUFNO0lBQ2xCO0lBRUFILFdBQVdJLFdBQVcsQ0FBQ1o7SUFDdkIsT0FBT0E7QUFDVDtBQUVBLElBQUlhLGtCQUFrQixTQUFTQSxnQkFBZ0JDLE1BQU0sRUFBRUMsU0FBUztJQUM5RCxJQUFJLENBQUNELFVBQVUsQ0FBQ0EsT0FBT0UsZ0JBQWdCLEVBQUU7UUFDdkM7SUFDRjtJQUVBRixPQUFPRSxnQkFBZ0IsQ0FBQztRQUN0QkMsTUFBTTtRQUNOQyxTQUFTO1FBQ1RILFdBQVdBO0lBQ2I7QUFDRjtB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RSxDQUFDLFFBQVEsQ0FBQyxTQUFVUixLQUFLO0lBQ3pCLElBQUksQ0FBQ08sWUFBWTtRQUNmZCxRQUFRQyxJQUFJLENBQUNNO0lBQ2Y7QUFDRjtBQUNBLElBQUlVLGFBQWEsU0FBU0E7SUFDeEIsSUFBSyxJQUFJQyxPQUFPQyxVQUFVbEQsTUFBTSxFQUFFeUMsT0FBTyxJQUFJVSxNQUFNRixPQUFPRyxPQUFPLEdBQUdBLE9BQU9ILE1BQU1HLE9BQVE7UUFDdkZYLElBQUksQ0FBQ1csS0FBSyxHQUFHRixTQUFTLENBQUNFLEtBQUs7SUFDOUI7SUFFQVAsYUFBYTtJQUNiLElBQUk3QixZQUFZcUMsS0FBS0MsR0FBRyxJQUFJLDZEQUE2RDtJQUV6RixPQUFPUixtQkFBbUJDLElBQUksQ0FBQyxTQUFVUCxXQUFXO1FBQ2xELE9BQU9ELFdBQVdDLGFBQWFDLE1BQU16QjtJQUN2QztBQUNGO0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicHJvZGlnaWVzLXBsdXJhLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvc3RyaXBlLWpzL2Rpc3Qvc3RyaXBlLmVzbS5qcz9lZjI1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBWM19VUkwgPSAnaHR0cHM6Ly9qcy5zdHJpcGUuY29tL3YzJztcbnZhciBWM19VUkxfUkVHRVggPSAvXmh0dHBzOlxcL1xcL2pzXFwuc3RyaXBlXFwuY29tXFwvdjNcXC8/KFxcPy4qKT8kLztcbnZhciBFWElTVElOR19TQ1JJUFRfTUVTU0FHRSA9ICdsb2FkU3RyaXBlLnNldExvYWRQYXJhbWV0ZXJzIHdhcyBjYWxsZWQgYnV0IGFuIGV4aXN0aW5nIFN0cmlwZS5qcyBzY3JpcHQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGRvY3VtZW50OyBleGlzdGluZyBzY3JpcHQgcGFyYW1ldGVycyB3aWxsIGJlIHVzZWQnO1xudmFyIGZpbmRTY3JpcHQgPSBmdW5jdGlvbiBmaW5kU2NyaXB0KCkge1xuICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRbc3JjXj1cXFwiXCIuY29uY2F0KFYzX1VSTCwgXCJcXFwiXVwiKSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbaV07XG5cbiAgICBpZiAoIVYzX1VSTF9SRUdFWC50ZXN0KHNjcmlwdC5zcmMpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NyaXB0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgaW5qZWN0U2NyaXB0ID0gZnVuY3Rpb24gaW5qZWN0U2NyaXB0KHBhcmFtcykge1xuICB2YXIgcXVlcnlTdHJpbmcgPSBwYXJhbXMgJiYgIXBhcmFtcy5hZHZhbmNlZEZyYXVkU2lnbmFscyA/ICc/YWR2YW5jZWRGcmF1ZFNpZ25hbHM9ZmFsc2UnIDogJyc7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0LnNyYyA9IFwiXCIuY29uY2F0KFYzX1VSTCkuY29uY2F0KHF1ZXJ5U3RyaW5nKTtcbiAgdmFyIGhlYWRPckJvZHkgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgaWYgKCFoZWFkT3JCb2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBkb2N1bWVudC5ib2R5IG5vdCB0byBiZSBudWxsLiBTdHJpcGUuanMgcmVxdWlyZXMgYSA8Ym9keT4gZWxlbWVudC4nKTtcbiAgfVxuXG4gIGhlYWRPckJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgcmV0dXJuIHNjcmlwdDtcbn07XG5cbnZhciByZWdpc3RlcldyYXBwZXIgPSBmdW5jdGlvbiByZWdpc3RlcldyYXBwZXIoc3RyaXBlLCBzdGFydFRpbWUpIHtcbiAgaWYgKCFzdHJpcGUgfHwgIXN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RyaXBlLl9yZWdpc3RlcldyYXBwZXIoe1xuICAgIG5hbWU6ICdzdHJpcGUtanMnLFxuICAgIHZlcnNpb246IFwiMi40LjBcIixcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZVxuICB9KTtcbn07XG5cbnZhciBzdHJpcGVQcm9taXNlID0gbnVsbDtcbnZhciBvbkVycm9yTGlzdGVuZXIgPSBudWxsO1xudmFyIG9uTG9hZExpc3RlbmVyID0gbnVsbDtcblxudmFyIG9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yKHJlamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIFN0cmlwZS5qcycpKTtcbiAgfTtcbn07XG5cbnZhciBvbkxvYWQgPSBmdW5jdGlvbiBvbkxvYWQocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdpbmRvdy5TdHJpcGUpIHtcbiAgICAgIHJlc29sdmUod2luZG93LlN0cmlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1N0cmlwZS5qcyBub3QgYXZhaWxhYmxlJykpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBsb2FkU2NyaXB0ID0gZnVuY3Rpb24gbG9hZFNjcmlwdChwYXJhbXMpIHtcbiAgLy8gRW5zdXJlIHRoYXQgd2Ugb25seSBhdHRlbXB0IHRvIGxvYWQgU3RyaXBlLmpzIGF0IG1vc3Qgb25jZVxuICBpZiAoc3RyaXBlUHJvbWlzZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzdHJpcGVQcm9taXNlO1xuICB9XG5cbiAgc3RyaXBlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gUmVzb2x2ZSB0byBudWxsIHdoZW4gaW1wb3J0ZWQgc2VydmVyIHNpZGUuIFRoaXMgbWFrZXMgdGhlIG1vZHVsZVxuICAgICAgLy8gc2FmZSB0byBpbXBvcnQgaW4gYW4gaXNvbW9ycGhpYyBjb2RlIGJhc2UuXG4gICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuU3RyaXBlICYmIHBhcmFtcykge1xuICAgICAgY29uc29sZS53YXJuKEVYSVNUSU5HX1NDUklQVF9NRVNTQUdFKTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LlN0cmlwZSkge1xuICAgICAgcmVzb2x2ZSh3aW5kb3cuU3RyaXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHNjcmlwdCA9IGZpbmRTY3JpcHQoKTtcblxuICAgICAgaWYgKHNjcmlwdCAmJiBwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKEVYSVNUSU5HX1NDUklQVF9NRVNTQUdFKTtcbiAgICAgIH0gZWxzZSBpZiAoIXNjcmlwdCkge1xuICAgICAgICBzY3JpcHQgPSBpbmplY3RTY3JpcHQocGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoc2NyaXB0ICYmIG9uTG9hZExpc3RlbmVyICE9PSBudWxsICYmIG9uRXJyb3JMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3NjcmlwdCRwYXJlbnROb2RlO1xuXG4gICAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgc2NyaXB0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWRMaXN0ZW5lcik7XG4gICAgICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3JMaXN0ZW5lcik7IC8vIGlmIHNjcmlwdCBleGlzdHMsIGJ1dCB3ZSBhcmUgcmVsb2FkaW5nIGR1ZSB0byBhbiBlcnJvcixcbiAgICAgICAgLy8gcmVsb2FkIHNjcmlwdCB0byB0cmlnZ2VyICdsb2FkJyBldmVudFxuXG4gICAgICAgIChfc2NyaXB0JHBhcmVudE5vZGUgPSBzY3JpcHQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX3NjcmlwdCRwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NyaXB0JHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgc2NyaXB0ID0gaW5qZWN0U2NyaXB0KHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIG9uTG9hZExpc3RlbmVyID0gb25Mb2FkKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICBvbkVycm9yTGlzdGVuZXIgPSBvbkVycm9yKHJlamVjdCk7XG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZExpc3RlbmVyKTtcbiAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3JMaXN0ZW5lcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9KTsgLy8gUmVzZXRzIHN0cmlwZVByb21pc2Ugb24gZXJyb3JcblxuICByZXR1cm4gc3RyaXBlUHJvbWlzZVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHN0cmlwZVByb21pc2UgPSBudWxsO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH0pO1xufTtcbnZhciBpbml0U3RyaXBlID0gZnVuY3Rpb24gaW5pdFN0cmlwZShtYXliZVN0cmlwZSwgYXJncywgc3RhcnRUaW1lKSB7XG4gIGlmIChtYXliZVN0cmlwZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHN0cmlwZSA9IG1heWJlU3RyaXBlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIHJlZ2lzdGVyV3JhcHBlcihzdHJpcGUsIHN0YXJ0VGltZSk7XG4gIHJldHVybiBzdHJpcGU7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuXG52YXIgc3RyaXBlUHJvbWlzZSQxO1xudmFyIGxvYWRDYWxsZWQgPSBmYWxzZTtcblxudmFyIGdldFN0cmlwZVByb21pc2UgPSBmdW5jdGlvbiBnZXRTdHJpcGVQcm9taXNlKCkge1xuICBpZiAoc3RyaXBlUHJvbWlzZSQxKSB7XG4gICAgcmV0dXJuIHN0cmlwZVByb21pc2UkMTtcbiAgfVxuXG4gIHN0cmlwZVByb21pc2UkMSA9IGxvYWRTY3JpcHQobnVsbClbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAvLyBjbGVhciBjYWNoZSBvbiBlcnJvclxuICAgIHN0cmlwZVByb21pc2UkMSA9IG51bGw7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfSk7XG4gIHJldHVybiBzdHJpcGVQcm9taXNlJDE7XG59OyAvLyBFeGVjdXRlIG91ciBvd24gc2NyaXB0IGluamVjdGlvbiBhZnRlciBhIHRpY2sgdG8gZ2l2ZSB1c2VycyB0aW1lIHRvIGRvIHRoZWlyXG4vLyBvd24gc2NyaXB0IGluamVjdGlvbi5cblxuXG5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGdldFN0cmlwZVByb21pc2UoKTtcbn0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gIGlmICghbG9hZENhbGxlZCkge1xuICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gIH1cbn0pO1xudmFyIGxvYWRTdHJpcGUgPSBmdW5jdGlvbiBsb2FkU3RyaXBlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgbG9hZENhbGxlZCA9IHRydWU7XG4gIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpOyAvLyBpZiBwcmV2aW91cyBhdHRlbXB0cyBhcmUgdW5zdWNjZXNzZnVsLCB3aWxsIHJlLWxvYWQgc2NyaXB0XG5cbiAgcmV0dXJuIGdldFN0cmlwZVByb21pc2UoKS50aGVuKGZ1bmN0aW9uIChtYXliZVN0cmlwZSkge1xuICAgIHJldHVybiBpbml0U3RyaXBlKG1heWJlU3RyaXBlLCBhcmdzLCBzdGFydFRpbWUpO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IGxvYWRTdHJpcGUgfTtcbiJdLCJuYW1lcyI6WyJWM19VUkwiLCJWM19VUkxfUkVHRVgiLCJFWElTVElOR19TQ1JJUFRfTUVTU0FHRSIsImZpbmRTY3JpcHQiLCJzY3JpcHRzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29uY2F0IiwiaSIsImxlbmd0aCIsInNjcmlwdCIsInRlc3QiLCJzcmMiLCJpbmplY3RTY3JpcHQiLCJwYXJhbXMiLCJxdWVyeVN0cmluZyIsImFkdmFuY2VkRnJhdWRTaWduYWxzIiwiY3JlYXRlRWxlbWVudCIsImhlYWRPckJvZHkiLCJoZWFkIiwiYm9keSIsIkVycm9yIiwiYXBwZW5kQ2hpbGQiLCJyZWdpc3RlcldyYXBwZXIiLCJzdHJpcGUiLCJzdGFydFRpbWUiLCJfcmVnaXN0ZXJXcmFwcGVyIiwibmFtZSIsInZlcnNpb24iLCJzdHJpcGVQcm9taXNlIiwib25FcnJvckxpc3RlbmVyIiwib25Mb2FkTGlzdGVuZXIiLCJvbkVycm9yIiwicmVqZWN0Iiwib25Mb2FkIiwicmVzb2x2ZSIsIndpbmRvdyIsIlN0cmlwZSIsImxvYWRTY3JpcHQiLCJQcm9taXNlIiwiY29uc29sZSIsIndhcm4iLCJfc2NyaXB0JHBhcmVudE5vZGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVycm9yIiwiaW5pdFN0cmlwZSIsIm1heWJlU3RyaXBlIiwiYXJncyIsImFwcGx5IiwidW5kZWZpbmVkIiwic3RyaXBlUHJvbWlzZSQxIiwibG9hZENhbGxlZCIsImdldFN0cmlwZVByb21pc2UiLCJ0aGVuIiwibG9hZFN0cmlwZSIsIl9sZW4iLCJhcmd1bWVudHMiLCJBcnJheSIsIl9rZXkiLCJEYXRlIiwibm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/dist/stripe.esm.js\n");

/***/ })

};
;