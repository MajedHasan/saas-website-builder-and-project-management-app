"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uploadthing";
exports.ids = ["vendor-chunks/uploadthing"];
exports.modules = {

/***/ "(ssr)/./node_modules/uploadthing/client/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/client/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DANGEROUS__uploadFiles: () => (/* binding */ DANGEROUS__uploadFiles),\n/* harmony export */   INTERNAL_DO_NOT_USE__fatalClientError: () => (/* binding */ INTERNAL_DO_NOT_USE__fatalClientError),\n/* harmony export */   INTERNAL_doFormatting: () => (/* binding */ INTERNAL_doFormatting),\n/* harmony export */   allowedContentTextLabelGenerator: () => (/* binding */ allowedContentTextLabelGenerator),\n/* harmony export */   capitalizeStart: () => (/* binding */ capitalizeStart),\n/* harmony export */   classNames: () => (/* binding */ classNames),\n/* harmony export */   contentFieldToContent: () => (/* binding */ contentFieldToContent),\n/* harmony export */   genUploader: () => (/* binding */ genUploader),\n/* harmony export */   generateClientDropzoneAccept: () => (/* binding */ generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* binding */ generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* binding */ generatePermittedFileTypes),\n/* harmony export */   resolveMaybeUrlArg: () => (/* binding */ resolveMaybeUrlArg),\n/* harmony export */   styleFieldToClassName: () => (/* binding */ styleFieldToClassName),\n/* harmony export */   styleFieldToCssObject: () => (/* binding */ styleFieldToCssObject)\n/* harmony export */ });\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(ssr)/./node_modules/@uploadthing/shared/dist/index.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! std-env */ \"(ssr)/./node_modules/std-env/dist/index.mjs\");\n\n\n/*\n * Returns a full URL to the dev's uploadthing endpoint\n * Can take either an origin, or a pathname, or a full URL\n * and will return the \"closest\" url matching the default\n * `<VERCEL_URL || localhost>/api/uploadthing`\n */ function getFullApiUrl(maybeUrl) {\n    const base = (()=>{\n        if (false) {}\n        if (std_env__WEBPACK_IMPORTED_MODULE_1__.process.env?.VERCEL_URL) return `https://${std_env__WEBPACK_IMPORTED_MODULE_1__.process.env.VERCEL_URL}`;\n        return \"http://localhost:3000\";\n    })();\n    try {\n        const url = new URL(maybeUrl ?? \"/api/uploadthing\", base);\n        if (url.pathname === \"/\") {\n            url.pathname = \"/api/uploadthing\";\n        }\n        return url;\n    } catch (err) {\n        throw new Error(`Failed to parse '${maybeUrl}' as a URL. Make sure it's a valid URL or path`);\n    }\n}\nfunction resolveMaybeUrlArg(maybeUrl) {\n    return maybeUrl instanceof URL ? maybeUrl : getFullApiUrl(maybeUrl);\n}\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n/**\n * Used by client uploads where progress is needed.\n * Uses XMLHttpRequest.\n */ async function uploadPartWithProgress(opts, retryCount = 0) {\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", opts.url, true);\n        xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n        xhr.setRequestHeader(\"Content-Disposition\", (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName));\n        xhr.onload = async ()=>{\n            if (xhr.status >= 200 && xhr.status < 300) {\n                const etag = xhr.getResponseHeader(\"Etag\");\n                etag ? resolve(etag) : reject(\"NO ETAG\");\n            } else if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 1000;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        let lastProgress = 0;\n        xhr.onerror = async ()=>{\n            lastProgress = 0;\n            if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 100;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        xhr.upload.onprogress = (e)=>{\n            const delta = e.loaded - lastProgress;\n            lastProgress += delta;\n            opts.onProgress(delta);\n        };\n        xhr.send(opts.chunk);\n    });\n}\nconst createAPIRequestUrl = (config)=>{\n    const url = new URL(config.url);\n    const queryParams = new URLSearchParams(url.search);\n    queryParams.set(\"actionType\", config.actionType);\n    queryParams.set(\"slug\", config.slug);\n    url.search = queryParams.toString();\n    return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L200\"\n */ const createUTReporter = (cfg)=>{\n    return async (type, payload)=>{\n        const url = createAPIRequestUrl({\n            url: cfg.url,\n            slug: cfg.endpoint,\n            actionType: type\n        });\n        const response = await cfg.fetch(url, {\n            method: \"POST\",\n            body: JSON.stringify(payload),\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-uploadthing-package\": cfg.package\n            }\n        });\n        switch(type){\n            case \"failure\":\n                {\n                    // why isn't this narrowed automatically?\n                    const p = payload;\n                    const parsed = maybeParseResponseXML(p.s3Error ?? \"\");\n                    if (parsed?.message) {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: parsed.code,\n                            message: parsed.message\n                        });\n                    } else {\n                        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"UPLOAD_FAILED\",\n                            message: `Failed to upload file ${p.fileName} to S3`,\n                            cause: p.s3Error\n                        });\n                    }\n                }\n        }\n        return response.ok;\n    };\n};\n/**\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */ const generatePermittedFileTypes = (config)=>{\n    const fileTypes = config ? (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(config) : [];\n    const maxFileCount = config ? Object.values(config).map((v)=>v.maxFileCount) : [];\n    return {\n        fileTypes,\n        multiple: maxFileCount.some((v)=>v && v > 1)\n    };\n};\nconst capitalizeStart = (str)=>{\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nconst INTERNAL_doFormatting = (config)=>{\n    if (!config) return \"\";\n    const allowedTypes = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(config);\n    const formattedTypes = allowedTypes.map((f)=>f === \"blob\" ? \"file\" : f);\n    // Format multi-type uploader label as \"Supports videos, images and files\";\n    if (formattedTypes.length > 1) {\n        const lastType = formattedTypes.pop();\n        return `${formattedTypes.join(\"s, \")} and ${lastType}s`;\n    }\n    // Single type uploader label\n    const key = allowedTypes[0];\n    const formattedKey = formattedTypes[0];\n    const { maxFileSize, maxFileCount } = config[key];\n    if (maxFileCount && maxFileCount > 1) {\n        return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;\n    } else {\n        return `${formattedKey} (${maxFileSize})`;\n    }\n};\nconst allowedContentTextLabelGenerator = (config)=>{\n    return capitalizeStart(INTERNAL_doFormatting(config));\n};\nconst styleFieldToClassName = (styleField, args)=>{\n    if (typeof styleField === \"string\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"string\") return result;\n    }\n    return \"\";\n};\nconst styleFieldToCssObject = (styleField, args)=>{\n    if (typeof styleField === \"object\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"object\") return result;\n    }\n    return {};\n};\nconst contentFieldToContent = (contentField, arg)=>{\n    if (!contentField) return null;\n    if (typeof contentField !== \"function\") return contentField;\n    if (typeof contentField === \"function\") {\n        const result = contentField(arg);\n        return result;\n    }\n};\n// Don't want to ship our logger to the client, keep size down\nconst INTERNAL_DO_NOT_USE__fatalClientError = (e)=>new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"INTERNAL_CLIENT_ERROR\",\n        message: \"Something went wrong. Please report this to UploadThing.\",\n        cause: e\n    });\nconst DANGEROUS__uploadFiles = async (endpoint, opts)=>{\n    // Fine to use global fetch in browser\n    const fetch = globalThis.fetch.bind(globalThis);\n    const reportEventToUT = createUTReporter({\n        endpoint: String(endpoint),\n        url: opts.url,\n        package: opts.package,\n        fetch\n    });\n    // Get presigned URL for S3 upload\n    const s3ConnectionRes = await fetch(createAPIRequestUrl({\n        url: opts.url,\n        slug: String(endpoint),\n        actionType: \"upload\"\n    }), {\n        method: \"POST\",\n        body: JSON.stringify({\n            input: \"input\" in opts ? opts.input : null,\n            files: opts.files.map((f)=>({\n                    name: f.name,\n                    size: f.size\n                }))\n        }),\n        // Express requires Content-Type to be explicitly set to parse body properly\n        headers: {\n            \"Content-Type\": \"application/json\",\n            \"x-uploadthing-package\": opts.package\n        }\n    }).then(async (res)=>{\n        // check for 200 response\n        if (!res.ok) {\n            const error = await _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.fromResponse(res);\n            throw error;\n        }\n        const jsonOrError = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(res);\n        if (jsonOrError instanceof Error) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: jsonOrError.message,\n                cause: res\n            });\n        }\n        return jsonOrError;\n    });\n    if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"No URL. How did you even get here?\",\n            cause: s3ConnectionRes\n        });\n    }\n    const fileUploadPromises = s3ConnectionRes.map(async (presigned)=>{\n        const file = opts.files.find((f)=>f.name === presigned.fileName);\n        if (!file) {\n            console.error(\"No file found for presigned URL\", presigned);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"NOT_FOUND\",\n                message: \"No file found for presigned URL\",\n                cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n            });\n        }\n        opts.onUploadBegin?.({\n            file: file.name\n        });\n        if (\"urls\" in presigned) {\n            await uploadMultipart(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n            // wait a bit as it's unsreasonable to expect the server to be done by now\n            await new Promise((r)=>setTimeout(r, 750));\n        } else {\n            await uploadPresignedPost(file, presigned, {\n                ...opts\n            });\n        }\n        const serverData = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.withExponentialBackoff)(async ()=>{\n            const res = await fetch(presigned.pollingUrl, {\n                headers: {\n                    authorization: presigned.pollingJwt\n                }\n            }).then((r)=>r.json());\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return res.status === \"done\" ? res.callbackData : undefined;\n        });\n        return {\n            name: file.name,\n            size: file.size,\n            key: presigned.key,\n            serverData,\n            url: \"https://utfs.io/f/\" + presigned.key\n        };\n    });\n    return Promise.all(fileUploadPromises);\n};\nconst genUploader = (initOpts)=>{\n    const url = resolveMaybeUrlArg(initOpts?.url);\n    const utPkg = initOpts.package;\n    return (endpoint, opts)=>DANGEROUS__uploadFiles(endpoint, {\n            ...opts,\n            url,\n            package: utPkg\n        });\n};\nconst classNames = (...classes)=>{\n    return classes.filter(Boolean).join(\" \");\n};\nconst generateMimeTypes = (fileTypes)=>{\n    const accepted = fileTypes.map((type)=>{\n        if (type === \"blob\") return \"blob\";\n        if (type === \"pdf\") return \"application/pdf\";\n        if (type.includes(\"/\")) return type;\n        else return `${type}/*`;\n    });\n    if (accepted.includes(\"blob\")) {\n        return undefined;\n    }\n    return accepted;\n};\nconst generateClientDropzoneAccept = (fileTypes)=>{\n    const mimeTypes = generateMimeTypes(fileTypes);\n    if (!mimeTypes) return undefined;\n    return Object.fromEntries(mimeTypes.map((type)=>[\n            type,\n            []\n        ]));\n};\nasync function uploadMultipart(file, presigned, opts) {\n    let etags;\n    let uploadedBytes = 0;\n    try {\n        etags = await Promise.all(presigned.urls.map(async (url, index)=>{\n            const offset = presigned.chunkSize * index;\n            const end = Math.min(offset + presigned.chunkSize, file.size);\n            const chunk = file.slice(offset, end);\n            const etag = await uploadPartWithProgress({\n                url,\n                chunk: chunk,\n                contentDisposition: presigned.contentDisposition,\n                fileType: file.type,\n                fileName: file.name,\n                maxRetries: 10,\n                onProgress: (delta)=>{\n                    uploadedBytes += delta;\n                    const percent = uploadedBytes / file.size * 100;\n                    opts.onUploadProgress?.({\n                        file: file.name,\n                        progress: percent\n                    });\n                }\n            });\n            return {\n                tag: etag,\n                partNumber: index + 1\n            };\n        }));\n    } catch (error) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: presigned.uploadId,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    }\n    // Tell the server that the upload is complete\n    const uploadOk = await opts.reportEventToUT(\"multipart-complete\", {\n        uploadId: presigned.uploadId,\n        fileKey: presigned.key,\n        etags\n    });\n    if (!uploadOk) {\n        console.log(\"Failed to alert UT of upload completion\");\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to alert UT of upload completion\"\n        });\n    }\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n    const formData = new FormData();\n    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n    formData.append(\"file\", file); // File data **MUST GO LAST**\n    const response = await new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", presigned.url);\n        xhr.setRequestHeader(\"Accept\", \"application/xml\");\n        xhr.upload.onprogress = (p)=>{\n            opts.onUploadProgress?.({\n                file: file.name,\n                progress: p.loaded / p.total * 100\n            });\n        };\n        xhr.onload = (e)=>resolve(e.target);\n        xhr.onerror = (e)=>reject(e);\n        xhr.send(formData);\n    });\n    if (response.status > 299 || response.status < 200) {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to upload file\",\n            cause: response\n        });\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEg7QUFDNUY7QUFFbEM7Ozs7O0NBS0MsR0FBRyxTQUFTTSxjQUFjQyxRQUFRO0lBQy9CLE1BQU1DLE9BQU8sQ0FBQztRQUNWLElBQUksS0FBNkIsRUFBRSxFQUE4QjtRQUNqRSxJQUFJSCw0Q0FBT0EsQ0FBQ08sR0FBRyxFQUFFQyxZQUFZLE9BQU8sQ0FBQyxRQUFRLEVBQUVSLDRDQUFPQSxDQUFDTyxHQUFHLENBQUNDLFVBQVUsQ0FBQyxDQUFDO1FBQ3ZFLE9BQU87SUFDWDtJQUNBLElBQUk7UUFDQSxNQUFNQyxNQUFNLElBQUlDLElBQUlSLFlBQVksb0JBQW9CQztRQUNwRCxJQUFJTSxJQUFJRSxRQUFRLEtBQUssS0FBSztZQUN0QkYsSUFBSUUsUUFBUSxHQUFHO1FBQ25CO1FBQ0EsT0FBT0Y7SUFDWCxFQUFFLE9BQU9HLEtBQUs7UUFDVixNQUFNLElBQUlDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRVgsU0FBUyw4Q0FBOEMsQ0FBQztJQUNoRztBQUNKO0FBQ0EsU0FBU1ksbUJBQW1CWixRQUFRO0lBQ2hDLE9BQU9BLG9CQUFvQlEsTUFBTVIsV0FBV0QsY0FBY0M7QUFDOUQ7QUFFQSxNQUFNYSx3QkFBd0IsQ0FBQ0M7SUFDM0IsTUFBTUMsWUFBWUQsU0FBU0UsS0FBSyxDQUFDO0lBQ2pDLE1BQU1DLGVBQWVILFNBQVNFLEtBQUssQ0FBQztJQUNwQyxNQUFNRSxPQUFPSCxXQUFXLENBQUMsRUFBRTtJQUMzQixNQUFNSSxVQUFVRixjQUFjLENBQUMsRUFBRTtJQUNqQyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsU0FBUyxPQUFPO0lBQzlCLE9BQU87UUFDSEQsTUFBTUUsdUJBQXVCLENBQUNGLEtBQUssSUFBSUc7UUFDdkNGO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUFHLE1BQU1FLHFCQUFxQjtBQUMvQixNQUFN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QVV0SSxHQUFHO1FBQzlCNkIsSUFBSUcsZ0JBQWdCLENBQUMsVUFBVTtRQUMvQkgsSUFBSWtCLE1BQU0sQ0FBQ0MsVUFBVSxHQUFHLENBQUM2QjtZQUNyQnJELEtBQUtvSixnQkFBZ0IsR0FBRztnQkFDcEJyQyxNQUFNQSxLQUFLVixJQUFJO2dCQUNmZ0QsVUFBVWhHLEVBQUUxQixNQUFNLEdBQUcwQixFQUFFOEcsS0FBSyxHQUFHO1lBQ25DO1FBQ0o7UUFDQTlKLElBQUlNLE1BQU0sR0FBRyxDQUFDYyxJQUFJdEIsUUFBUXNCLEVBQUUySSxNQUFNO1FBQ2xDL0osSUFBSWlCLE9BQU8sR0FBRyxDQUFDRyxJQUFJckIsT0FBT3FCO1FBQzFCcEIsSUFBSXdCLElBQUksQ0FBQytIO0lBQ2I7SUFDQSxJQUFJL0csU0FBU2pDLE1BQU0sR0FBRyxPQUFPaUMsU0FBU2pDLE1BQU0sR0FBRyxLQUFLO1FBQ2hELE1BQU0sSUFBSWpELGlFQUFnQkEsQ0FBQztZQUN2QndCLE1BQU07WUFDTkMsU0FBUztZQUNUb0UsT0FBT1g7UUFDWDtJQUNKO0FBQ0o7QUFFa1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtcGx1cmEvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvY2xpZW50L2luZGV4LmpzPzZmNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29udGVudERpc3Bvc2l0aW9uLCBVcGxvYWRUaGluZ0Vycm9yLCBvYmplY3RLZXlzLCBzYWZlUGFyc2VKU09OLCB3aXRoRXhwb25lbnRpYWxCYWNrb2ZmIH0gZnJvbSAnQHVwbG9hZHRoaW5nL3NoYXJlZCc7XG5pbXBvcnQgeyBwcm9jZXNzIH0gZnJvbSAnc3RkLWVudic7XG5cbi8qXG4gKiBSZXR1cm5zIGEgZnVsbCBVUkwgdG8gdGhlIGRldidzIHVwbG9hZHRoaW5nIGVuZHBvaW50XG4gKiBDYW4gdGFrZSBlaXRoZXIgYW4gb3JpZ2luLCBvciBhIHBhdGhuYW1lLCBvciBhIGZ1bGwgVVJMXG4gKiBhbmQgd2lsbCByZXR1cm4gdGhlIFwiY2xvc2VzdFwiIHVybCBtYXRjaGluZyB0aGUgZGVmYXVsdFxuICogYDxWRVJDRUxfVVJMIHx8IGxvY2FsaG9zdD4vYXBpL3VwbG9hZHRoaW5nYFxuICovIGZ1bmN0aW9uIGdldEZ1bGxBcGlVcmwobWF5YmVVcmwpIHtcbiAgICBjb25zdCBiYXNlID0gKCgpPT57XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Py5WRVJDRUxfVVJMKSByZXR1cm4gYGh0dHBzOi8vJHtwcm9jZXNzLmVudi5WRVJDRUxfVVJMfWA7XG4gICAgICAgIHJldHVybiBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiO1xuICAgIH0pKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChtYXliZVVybCA/PyBcIi9hcGkvdXBsb2FkdGhpbmdcIiwgYmFzZSk7XG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICB1cmwucGF0aG5hbWUgPSBcIi9hcGkvdXBsb2FkdGhpbmdcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSAnJHttYXliZVVybH0nIGFzIGEgVVJMLiBNYWtlIHN1cmUgaXQncyBhIHZhbGlkIFVSTCBvciBwYXRoYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZU1heWJlVXJsQXJnKG1heWJlVXJsKSB7XG4gICAgcmV0dXJuIG1heWJlVXJsIGluc3RhbmNlb2YgVVJMID8gbWF5YmVVcmwgOiBnZXRGdWxsQXBpVXJsKG1heWJlVXJsKTtcbn1cblxuY29uc3QgbWF5YmVQYXJzZVJlc3BvbnNlWE1MID0gKG1heWJlWG1sKT0+e1xuICAgIGNvbnN0IGNvZGVNYXRjaCA9IG1heWJlWG1sLm1hdGNoKC88Q29kZT4oLio/KTxcXC9Db2RlPi9zKTtcbiAgICBjb25zdCBtZXNzYWdlTWF0Y2ggPSBtYXliZVhtbC5tYXRjaCgvPE1lc3NhZ2U+KC4qPyk8XFwvTWVzc2FnZT4vcyk7XG4gICAgY29uc3QgY29kZSA9IGNvZGVNYXRjaD8uWzFdO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlTWF0Y2g/LlsxXTtcbiAgICBpZiAoIWNvZGUgfHwgIW1lc3NhZ2UpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlW2NvZGVdID8/IERFRkFVTFRfRVJST1JfQ09ERSxcbiAgICAgICAgbWVzc2FnZVxuICAgIH07XG59O1xuLyoqXG4gKiBNYXAgUzMgZXJyb3IgY29kZXMgdG8gVXBsb2FkVGhpbmcgZXJyb3IgY29kZXNcbiAqXG4gKiBUaGlzIGlzIGEgc3Vic2V0IG9mIHRoZSBTMyBlcnJvciBjb2RlcywgYmFzZWQgb24gd2hhdCBzZWVtZWQgbW9zdCBsaWtlbHkgdG9cbiAqIG9jY3VyIGluIHVwbG9hZHRoaW5nLiBGb3IgYSBmdWxsIGxpc3Qgb2YgUzMgZXJyb3IgY29kZXMsIHNlZTpcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvQVBJL0Vycm9yUmVzcG9uc2VzLmh0bWxcbiAqLyBjb25zdCBERUZBVUxUX0VSUk9SX0NPREUgPSBcIlVQTE9BRF9GQUlMRURcIjtcbmNvbnN0IHMzQ29kZVRvVXBsb2FkVGhpbmdDb2RlID0ge1xuICAgIEFjY2Vzc0RlbmllZDogXCJGT1JCSURERU5cIixcbiAgICBFbnRpdHlUb29TbWFsbDogXCJUT09fU01BTExcIixcbiAgICBFbnRpdHlUb29MYXJnZTogXCJUT09fTEFSR0VcIixcbiAgICBFeHBpcmVkVG9rZW46IFwiRk9SQklEREVOXCIsXG4gICAgSW5jb3JyZWN0TnVtYmVyT2ZGaWxlc0luUG9zdFJlcXVlc3Q6IFwiVE9PX01BTllfRklMRVNcIixcbiAgICBJbnRlcm5hbEVycm9yOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgIEtleVRvb0xvbmdFcnJvcjogXCJLRVlfVE9PX0xPTkdcIixcbiAgICBNYXhNZXNzYWdlTGVuZ3RoRXhjZWVkZWQ6IFwiVE9PX0xBUkdFXCJcbn07XG5cbi8qKlxuICogVXNlZCBieSBjbGllbnQgdXBsb2FkcyB3aGVyZSBwcm9ncmVzcyBpcyBuZWVkZWQuXG4gKiBVc2VzIFhNTEh0dHBSZXF1ZXN0LlxuICovIGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFBhcnRXaXRoUHJvZ3Jlc3Mob3B0cywgcmV0cnlDb3VudCA9IDApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKFwiUFVUXCIsIG9wdHMudXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgb3B0cy5maWxlVHlwZSk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiLCBjb250ZW50RGlzcG9zaXRpb24ob3B0cy5jb250ZW50RGlzcG9zaXRpb24sIG9wdHMuZmlsZU5hbWUpKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV0YWcgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJFdGFnXCIpO1xuICAgICAgICAgICAgICAgIGV0YWcgPyByZXNvbHZlKGV0YWcpIDogcmVqZWN0KFwiTk8gRVRBR1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0cnlDb3VudCA8IG9wdHMubWF4UmV0cmllcykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIGRlbGF5IGJlZm9yZSByZXRyeWluZyAoZXhwb25lbnRpYWwgYmFja29mZiBjYW4gYmUgdXNlZClcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogMTAwMDtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKT0+c2V0VGltZW91dChyZXMsIGRlbGF5KSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkUGFydFdpdGhQcm9ncmVzcyhvcHRzLCByZXRyeUNvdW50ICsgMSk7IC8vIFJldHJ5IHRoZSByZXF1ZXN0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChcIk1heCByZXRyaWVzIGV4Y2VlZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgbGFzdFByb2dyZXNzID0gMDtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgbGFzdFByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIGlmIChyZXRyeUNvdW50IDwgb3B0cy5tYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgZGVsYXkgYmVmb3JlIHJldHJ5aW5nIChleHBvbmVudGlhbCBiYWNrb2ZmIGNhbiBiZSB1c2VkKVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5wb3coMiwgcmV0cnlDb3VudCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcyk9PnNldFRpbWVvdXQocmVzLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZFBhcnRXaXRoUHJvZ3Jlc3Mob3B0cywgcmV0cnlDb3VudCArIDEpOyAvLyBSZXRyeSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJNYXggcmV0cmllcyBleGNlZWRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGUubG9hZGVkIC0gbGFzdFByb2dyZXNzO1xuICAgICAgICAgICAgbGFzdFByb2dyZXNzICs9IGRlbHRhO1xuICAgICAgICAgICAgb3B0cy5vblByb2dyZXNzKGRlbHRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQob3B0cy5jaHVuayk7XG4gICAgfSk7XG59XG5cbmNvbnN0IGNyZWF0ZUFQSVJlcXVlc3RVcmwgPSAoY29uZmlnKT0+e1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoY29uZmlnLnVybCk7XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5zZWFyY2gpO1xuICAgIHF1ZXJ5UGFyYW1zLnNldChcImFjdGlvblR5cGVcIiwgY29uZmlnLmFjdGlvblR5cGUpO1xuICAgIHF1ZXJ5UGFyYW1zLnNldChcInNsdWdcIiwgY29uZmlnLnNsdWcpO1xuICAgIHVybC5zZWFyY2ggPSBxdWVyeVBhcmFtcy50b1N0cmluZygpO1xuICAgIHJldHVybiB1cmw7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgXCJjbGllbnRcIiBmb3IgcmVwb3J0aW5nIGV2ZW50cyB0byB0aGUgVXBsb2FkVGhpbmcgc2VydmVyIHZpYSB0aGUgdXNlcidzIEFQSSBlbmRwb2ludC5cbiAqIEV2ZW50cyBhcmUgaGFuZGxlZCBpbiBcIi4vaGFuZGxlci50cyBzdGFydGluZyBhdCBMMjAwXCJcbiAqLyBjb25zdCBjcmVhdGVVVFJlcG9ydGVyID0gKGNmZyk9PntcbiAgICByZXR1cm4gYXN5bmMgKHR5cGUsIHBheWxvYWQpPT57XG4gICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZUFQSVJlcXVlc3RVcmwoe1xuICAgICAgICAgICAgdXJsOiBjZmcudXJsLFxuICAgICAgICAgICAgc2x1ZzogY2ZnLmVuZHBvaW50LFxuICAgICAgICAgICAgYWN0aW9uVHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjZmcuZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXBhY2thZ2VcIjogY2ZnLnBhY2thZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aHkgaXNuJ3QgdGhpcyBuYXJyb3dlZCBhdXRvbWF0aWNhbGx5P1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbWF5YmVQYXJzZVJlc3BvbnNlWE1MKHAuczNFcnJvciA/PyBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZD8ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcnNlZC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBhcnNlZC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIHVwbG9hZCBmaWxlICR7cC5maWxlTmFtZX0gdG8gUzNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBwLnMzRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICB9O1xufTtcblxuLyoqXG4gKiBTaGFyZWQgaGVscGVycyBmb3Igb3VyIHByZW1hZGUgY29tcG9uZW50cyB0aGF0J3MgcmV1c2FibGUgYnkgbXVsdGlwbGUgZnJhbWV3b3Jrc1xuICovIGNvbnN0IGdlbmVyYXRlUGVybWl0dGVkRmlsZVR5cGVzID0gKGNvbmZpZyk9PntcbiAgICBjb25zdCBmaWxlVHlwZXMgPSBjb25maWcgPyBvYmplY3RLZXlzKGNvbmZpZykgOiBbXTtcbiAgICBjb25zdCBtYXhGaWxlQ291bnQgPSBjb25maWcgPyBPYmplY3QudmFsdWVzKGNvbmZpZykubWFwKCh2KT0+di5tYXhGaWxlQ291bnQpIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVR5cGVzLFxuICAgICAgICBtdWx0aXBsZTogbWF4RmlsZUNvdW50LnNvbWUoKHYpPT52ICYmIHYgPiAxKVxuICAgIH07XG59O1xuY29uc3QgY2FwaXRhbGl6ZVN0YXJ0ID0gKHN0cik9PntcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcbmNvbnN0IElOVEVSTkFMX2RvRm9ybWF0dGluZyA9IChjb25maWcpPT57XG4gICAgaWYgKCFjb25maWcpIHJldHVybiBcIlwiO1xuICAgIGNvbnN0IGFsbG93ZWRUeXBlcyA9IG9iamVjdEtleXMoY29uZmlnKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRUeXBlcyA9IGFsbG93ZWRUeXBlcy5tYXAoKGYpPT5mID09PSBcImJsb2JcIiA/IFwiZmlsZVwiIDogZik7XG4gICAgLy8gRm9ybWF0IG11bHRpLXR5cGUgdXBsb2FkZXIgbGFiZWwgYXMgXCJTdXBwb3J0cyB2aWRlb3MsIGltYWdlcyBhbmQgZmlsZXNcIjtcbiAgICBpZiAoZm9ybWF0dGVkVHlwZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBsYXN0VHlwZSA9IGZvcm1hdHRlZFR5cGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gYCR7Zm9ybWF0dGVkVHlwZXMuam9pbihcInMsIFwiKX0gYW5kICR7bGFzdFR5cGV9c2A7XG4gICAgfVxuICAgIC8vIFNpbmdsZSB0eXBlIHVwbG9hZGVyIGxhYmVsXG4gICAgY29uc3Qga2V5ID0gYWxsb3dlZFR5cGVzWzBdO1xuICAgIGNvbnN0IGZvcm1hdHRlZEtleSA9IGZvcm1hdHRlZFR5cGVzWzBdO1xuICAgIGNvbnN0IHsgbWF4RmlsZVNpemUsIG1heEZpbGVDb3VudCB9ID0gY29uZmlnW2tleV07XG4gICAgaWYgKG1heEZpbGVDb3VudCAmJiBtYXhGaWxlQ291bnQgPiAxKSB7XG4gICAgICAgIHJldHVybiBgJHtmb3JtYXR0ZWRLZXl9cyB1cCB0byAke21heEZpbGVTaXplfSwgbWF4ICR7bWF4RmlsZUNvdW50fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke2Zvcm1hdHRlZEtleX0gKCR7bWF4RmlsZVNpemV9KWA7XG4gICAgfVxufTtcbmNvbnN0IGFsbG93ZWRDb250ZW50VGV4dExhYmVsR2VuZXJhdG9yID0gKGNvbmZpZyk9PntcbiAgICByZXR1cm4gY2FwaXRhbGl6ZVN0YXJ0KElOVEVSTkFMX2RvRm9ybWF0dGluZyhjb25maWcpKTtcbn07XG5jb25zdCBzdHlsZUZpZWxkVG9DbGFzc05hbWUgPSAoc3R5bGVGaWVsZCwgYXJncyk9PntcbiAgICBpZiAodHlwZW9mIHN0eWxlRmllbGQgPT09IFwic3RyaW5nXCIpIHJldHVybiBzdHlsZUZpZWxkO1xuICAgIGlmICh0eXBlb2Ygc3R5bGVGaWVsZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0eWxlRmllbGQoYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn07XG5jb25zdCBzdHlsZUZpZWxkVG9Dc3NPYmplY3QgPSAoc3R5bGVGaWVsZCwgYXJncyk9PntcbiAgICBpZiAodHlwZW9mIHN0eWxlRmllbGQgPT09IFwib2JqZWN0XCIpIHJldHVybiBzdHlsZUZpZWxkO1xuICAgIGlmICh0eXBlb2Ygc3R5bGVGaWVsZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0eWxlRmllbGQoYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge307XG59O1xuY29uc3QgY29udGVudEZpZWxkVG9Db250ZW50ID0gKGNvbnRlbnRGaWVsZCwgYXJnKT0+e1xuICAgIGlmICghY29udGVudEZpZWxkKSByZXR1cm4gbnVsbDtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnRGaWVsZCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udGVudEZpZWxkO1xuICAgIGlmICh0eXBlb2YgY29udGVudEZpZWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29udGVudEZpZWxkKGFyZyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxuLy8gRG9uJ3Qgd2FudCB0byBzaGlwIG91ciBsb2dnZXIgdG8gdGhlIGNsaWVudCwga2VlcCBzaXplIGRvd25cbmNvbnN0IElOVEVSTkFMX0RPX05PVF9VU0VfX2ZhdGFsQ2xpZW50RXJyb3IgPSAoZSk9Pm5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgY29kZTogXCJJTlRFUk5BTF9DTElFTlRfRVJST1JcIixcbiAgICAgICAgbWVzc2FnZTogXCJTb21ldGhpbmcgd2VudCB3cm9uZy4gUGxlYXNlIHJlcG9ydCB0aGlzIHRvIFVwbG9hZFRoaW5nLlwiLFxuICAgICAgICBjYXVzZTogZVxuICAgIH0pO1xuY29uc3QgREFOR0VST1VTX191cGxvYWRGaWxlcyA9IGFzeW5jIChlbmRwb2ludCwgb3B0cyk9PntcbiAgICAvLyBGaW5lIHRvIHVzZSBnbG9iYWwgZmV0Y2ggaW4gYnJvd3NlclxuICAgIGNvbnN0IGZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaC5iaW5kKGdsb2JhbFRoaXMpO1xuICAgIGNvbnN0IHJlcG9ydEV2ZW50VG9VVCA9IGNyZWF0ZVVUUmVwb3J0ZXIoe1xuICAgICAgICBlbmRwb2ludDogU3RyaW5nKGVuZHBvaW50KSxcbiAgICAgICAgdXJsOiBvcHRzLnVybCxcbiAgICAgICAgcGFja2FnZTogb3B0cy5wYWNrYWdlLFxuICAgICAgICBmZXRjaFxuICAgIH0pO1xuICAgIC8vIEdldCBwcmVzaWduZWQgVVJMIGZvciBTMyB1cGxvYWRcbiAgICBjb25zdCBzM0Nvbm5lY3Rpb25SZXMgPSBhd2FpdCBmZXRjaChjcmVhdGVBUElSZXF1ZXN0VXJsKHtcbiAgICAgICAgdXJsOiBvcHRzLnVybCxcbiAgICAgICAgc2x1ZzogU3RyaW5nKGVuZHBvaW50KSxcbiAgICAgICAgYWN0aW9uVHlwZTogXCJ1cGxvYWRcIlxuICAgIH0pLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGlucHV0OiBcImlucHV0XCIgaW4gb3B0cyA/IG9wdHMuaW5wdXQgOiBudWxsLFxuICAgICAgICAgICAgZmlsZXM6IG9wdHMuZmlsZXMubWFwKChmKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBmLnNpemVcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgfSksXG4gICAgICAgIC8vIEV4cHJlc3MgcmVxdWlyZXMgQ29udGVudC1UeXBlIHRvIGJlIGV4cGxpY2l0bHkgc2V0IHRvIHBhcnNlIGJvZHkgcHJvcGVybHlcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctcGFja2FnZVwiOiBvcHRzLnBhY2thZ2VcbiAgICAgICAgfVxuICAgIH0pLnRoZW4oYXN5bmMgKHJlcyk9PntcbiAgICAgICAgLy8gY2hlY2sgZm9yIDIwMCByZXNwb25zZVxuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCBVcGxvYWRUaGluZ0Vycm9yLmZyb21SZXNwb25zZShyZXMpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNvbk9yRXJyb3IgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHJlcyk7XG4gICAgICAgIGlmIChqc29uT3JFcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGpzb25PckVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgY2F1c2U6IHJlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb25PckVycm9yO1xuICAgIH0pO1xuICAgIGlmICghczNDb25uZWN0aW9uUmVzIHx8ICFBcnJheS5pc0FycmF5KHMzQ29ubmVjdGlvblJlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogXCJObyBVUkwuIEhvdyBkaWQgeW91IGV2ZW4gZ2V0IGhlcmU/XCIsXG4gICAgICAgICAgICBjYXVzZTogczNDb25uZWN0aW9uUmVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBmaWxlVXBsb2FkUHJvbWlzZXMgPSBzM0Nvbm5lY3Rpb25SZXMubWFwKGFzeW5jIChwcmVzaWduZWQpPT57XG4gICAgICAgIGNvbnN0IGZpbGUgPSBvcHRzLmZpbGVzLmZpbmQoKGYpPT5mLm5hbWUgPT09IHByZXNpZ25lZC5maWxlTmFtZSk7XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGZpbGUgZm91bmQgZm9yIHByZXNpZ25lZCBVUkxcIiwgcHJlc2lnbmVkKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIk5PVF9GT1VORFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gZmlsZSBmb3VuZCBmb3IgcHJlc2lnbmVkIFVSTFwiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBgRXhwZWN0ZWQgZmlsZSB3aXRoIG5hbWUgJHtwcmVzaWduZWQuZmlsZU5hbWV9IGJ1dCBnb3QgJyR7b3B0cy5maWxlcy5qb2luKFwiLFwiKX0nYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5vblVwbG9hZEJlZ2luPy4oe1xuICAgICAgICAgICAgZmlsZTogZmlsZS5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoXCJ1cmxzXCIgaW4gcHJlc2lnbmVkKSB7XG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRNdWx0aXBhcnQoZmlsZSwgcHJlc2lnbmVkLCB7XG4gICAgICAgICAgICAgICAgcmVwb3J0RXZlbnRUb1VULFxuICAgICAgICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2FpdCBhIGJpdCBhcyBpdCdzIHVuc3JlYXNvbmFibGUgdG8gZXhwZWN0IHRoZSBzZXJ2ZXIgdG8gYmUgZG9uZSBieSBub3dcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKT0+c2V0VGltZW91dChyLCA3NTApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHVwbG9hZFByZXNpZ25lZFBvc3QoZmlsZSwgcHJlc2lnbmVkLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmVyRGF0YSA9IGF3YWl0IHdpdGhFeHBvbmVudGlhbEJhY2tvZmYoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHByZXNpZ25lZC5wb2xsaW5nVXJsLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBwcmVzaWduZWQucG9sbGluZ0p3dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oKHIpPT5yLmpzb24oKSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgIHJldHVybiByZXMuc3RhdHVzID09PSBcImRvbmVcIiA/IHJlcy5jYWxsYmFja0RhdGEgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAga2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgc2VydmVyRGF0YSxcbiAgICAgICAgICAgIHVybDogXCJodHRwczovL3V0ZnMuaW8vZi9cIiArIHByZXNpZ25lZC5rZXlcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmlsZVVwbG9hZFByb21pc2VzKTtcbn07XG5jb25zdCBnZW5VcGxvYWRlciA9IChpbml0T3B0cyk9PntcbiAgICBjb25zdCB1cmwgPSByZXNvbHZlTWF5YmVVcmxBcmcoaW5pdE9wdHM/LnVybCk7XG4gICAgY29uc3QgdXRQa2cgPSBpbml0T3B0cy5wYWNrYWdlO1xuICAgIHJldHVybiAoZW5kcG9pbnQsIG9wdHMpPT4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICBEQU5HRVJPVVNfX3VwbG9hZEZpbGVzKGVuZHBvaW50LCB7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgcGFja2FnZTogdXRQa2dcbiAgICAgICAgfSk7XG59O1xuY29uc3QgY2xhc3NOYW1lcyA9ICguLi5jbGFzc2VzKT0+e1xuICAgIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbn07XG5jb25zdCBnZW5lcmF0ZU1pbWVUeXBlcyA9IChmaWxlVHlwZXMpPT57XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBmaWxlVHlwZXMubWFwKCh0eXBlKT0+e1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJibG9iXCIpIHJldHVybiBcImJsb2JcIjtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwicGRmXCIpIHJldHVybiBcImFwcGxpY2F0aW9uL3BkZlwiO1xuICAgICAgICBpZiAodHlwZS5pbmNsdWRlcyhcIi9cIikpIHJldHVybiB0eXBlO1xuICAgICAgICBlbHNlIHJldHVybiBgJHt0eXBlfS8qYDtcbiAgICB9KTtcbiAgICBpZiAoYWNjZXB0ZWQuaW5jbHVkZXMoXCJibG9iXCIpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBhY2NlcHRlZDtcbn07XG5jb25zdCBnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0ID0gKGZpbGVUeXBlcyk9PntcbiAgICBjb25zdCBtaW1lVHlwZXMgPSBnZW5lcmF0ZU1pbWVUeXBlcyhmaWxlVHlwZXMpO1xuICAgIGlmICghbWltZVR5cGVzKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMobWltZVR5cGVzLm1hcCgodHlwZSk9PltcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBbXVxuICAgICAgICBdKSk7XG59O1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkTXVsdGlwYXJ0KGZpbGUsIHByZXNpZ25lZCwgb3B0cykge1xuICAgIGxldCBldGFncztcbiAgICBsZXQgdXBsb2FkZWRCeXRlcyA9IDA7XG4gICAgdHJ5IHtcbiAgICAgICAgZXRhZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChwcmVzaWduZWQudXJscy5tYXAoYXN5bmMgKHVybCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwcmVzaWduZWQuY2h1bmtTaXplICogaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihvZmZzZXQgKyBwcmVzaWduZWQuY2h1bmtTaXplLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKG9mZnNldCwgZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGV0YWcgPSBhd2FpdCB1cGxvYWRQYXJ0V2l0aFByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcHJlc2lnbmVkLmNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBmaWxlVHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgbWF4UmV0cmllczogMTAsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzczogKGRlbHRhKT0+e1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZEJ5dGVzICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50ID0gdXBsb2FkZWRCeXRlcyAvIGZpbGUuc2l6ZSAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5vblVwbG9hZFByb2dyZXNzPy4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHBlcmNlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhZzogZXRhZyxcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBpbmRleCArIDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBhd2FpdCBvcHRzLnJlcG9ydEV2ZW50VG9VVChcImZhaWx1cmVcIiwge1xuICAgICAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgICAgIHVwbG9hZElkOiBwcmVzaWduZWQudXBsb2FkSWQsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgczNFcnJvcjogZXJyb3IudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgXCJ1bnJlYWNoYWJsZVwiOyAvLyBmYWlsdXJlIGV2ZW50IHdpbGwgdGhyb3cgZm9yIHVzXG4gICAgfVxuICAgIC8vIFRlbGwgdGhlIHNlcnZlciB0aGF0IHRoZSB1cGxvYWQgaXMgY29tcGxldGVcbiAgICBjb25zdCB1cGxvYWRPayA9IGF3YWl0IG9wdHMucmVwb3J0RXZlbnRUb1VUKFwibXVsdGlwYXJ0LWNvbXBsZXRlXCIsIHtcbiAgICAgICAgdXBsb2FkSWQ6IHByZXNpZ25lZC51cGxvYWRJZCxcbiAgICAgICAgZmlsZUtleTogcHJlc2lnbmVkLmtleSxcbiAgICAgICAgZXRhZ3NcbiAgICB9KTtcbiAgICBpZiAoIXVwbG9hZE9rKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGFsZXJ0IFVUIG9mIHVwbG9hZCBjb21wbGV0aW9uXCIpO1xuICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIGFsZXJ0IFVUIG9mIHVwbG9hZCBjb21wbGV0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkUHJlc2lnbmVkUG9zdChmaWxlLCBwcmVzaWduZWQsIG9wdHMpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIE9iamVjdC5lbnRyaWVzKHByZXNpZ25lZC5maWVsZHMpLmZvckVhY2goKFtrLCB2XSk9PmZvcm1EYXRhLmFwcGVuZChrLCB2KSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKTsgLy8gRmlsZSBkYXRhICoqTVVTVCBHTyBMQVNUKipcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihcIlBPU1RcIiwgcHJlc2lnbmVkLnVybCk7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24veG1sXCIpO1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSAocCk9PntcbiAgICAgICAgICAgIG9wdHMub25VcGxvYWRQcm9ncmVzcz8uKHtcbiAgICAgICAgICAgICAgICBmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHAubG9hZGVkIC8gcC50b3RhbCAqIDEwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmxvYWQgPSAoZSk9PnJlc29sdmUoZS50YXJnZXQpO1xuICAgICAgICB4aHIub25lcnJvciA9IChlKT0+cmVqZWN0KGUpO1xuICAgICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+IDI5OSB8fCByZXNwb25zZS5zdGF0dXMgPCAyMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byB1cGxvYWQgZmlsZVwiLFxuICAgICAgICAgICAgY2F1c2U6IHJlc3BvbnNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgREFOR0VST1VTX191cGxvYWRGaWxlcywgSU5URVJOQUxfRE9fTk9UX1VTRV9fZmF0YWxDbGllbnRFcnJvciwgSU5URVJOQUxfZG9Gb3JtYXR0aW5nLCBhbGxvd2VkQ29udGVudFRleHRMYWJlbEdlbmVyYXRvciwgY2FwaXRhbGl6ZVN0YXJ0LCBjbGFzc05hbWVzLCBjb250ZW50RmllbGRUb0NvbnRlbnQsIGdlblVwbG9hZGVyLCBnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0LCBnZW5lcmF0ZU1pbWVUeXBlcywgZ2VuZXJhdGVQZXJtaXR0ZWRGaWxlVHlwZXMsIHJlc29sdmVNYXliZVVybEFyZywgc3R5bGVGaWVsZFRvQ2xhc3NOYW1lLCBzdHlsZUZpZWxkVG9Dc3NPYmplY3QgfTtcbiJdLCJuYW1lcyI6WyJjb250ZW50RGlzcG9zaXRpb24iLCJVcGxvYWRUaGluZ0Vycm9yIiwib2JqZWN0S2V5cyIsInNhZmVQYXJzZUpTT04iLCJ3aXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwicHJvY2VzcyIsImdldEZ1bGxBcGlVcmwiLCJtYXliZVVybCIsImJhc2UiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImVudiIsIlZFUkNFTF9VUkwiLCJ1cmwiLCJVUkwiLCJwYXRobmFtZSIsImVyciIsIkVycm9yIiwicmVzb2x2ZU1heWJlVXJsQXJnIiwibWF5YmVQYXJzZVJlc3BvbnNlWE1MIiwibWF5YmVYbWwiLCJjb2RlTWF0Y2giLCJtYXRjaCIsIm1lc3NhZ2VNYXRjaCIsImNvZGUiLCJtZXNzYWdlIiwiczNDb2RlVG9VcGxvYWRUaGluZ0NvZGUiLCJERUZBVUxUX0VSUk9SX0NPREUiLCJBY2Nlc3NEZW5pZWQiLCJFbnRpdHlUb29TbWFsbCIsIkVudGl0eVRvb0xhcmdlIiwiRXhwaXJlZFRva2VuIiwiSW5jb3JyZWN0TnVtYmVyT2ZGaWxlc0luUG9zdFJlcXVlc3QiLCJJbnRlcm5hbEVycm9yIiwiS2V5VG9vTG9uZ0Vycm9yIiwiTWF4TWVzc2FnZUxlbmd0aEV4Y2VlZGVkIiwidXBsb2FkUGFydFdpdGhQcm9ncmVzcyIsIm9wdHMiLCJyZXRyeUNvdW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwiZmlsZVR5cGUiLCJmaWxlTmFtZSIsIm9ubG9hZCIsInN0YXR1cyIsImV0YWciLCJnZXRSZXNwb25zZUhlYWRlciIsIm1heFJldHJpZXMiLCJkZWxheSIsIk1hdGgiLCJwb3ciLCJyZXMiLCJzZXRUaW1lb3V0IiwibGFzdFByb2dyZXNzIiwib25lcnJvciIsInVwbG9hZCIsIm9ucHJvZ3Jlc3MiLCJlIiwiZGVsdGEiLCJsb2FkZWQiLCJvblByb2dyZXNzIiwic2VuZCIsImNodW5rIiwiY3JlYXRlQVBJUmVxdWVzdFVybCIsImNvbmZpZyIsInF1ZXJ5UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwic2V0IiwiYWN0aW9uVHlwZSIsInNsdWciLCJ0b1N0cmluZyIsImNyZWF0ZVVUUmVwb3J0ZXIiLCJjZmciLCJ0eXBlIiwicGF5bG9hZCIsImVuZHBvaW50IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiaGVhZGVycyIsInBhY2thZ2UiLCJwIiwicGFyc2VkIiwiczNFcnJvciIsImNhdXNlIiwib2siLCJnZW5lcmF0ZVBlcm1pdHRlZEZpbGVUeXBlcyIsImZpbGVUeXBlcyIsIm1heEZpbGVDb3VudCIsIk9iamVjdCIsInZhbHVlcyIsIm1hcCIsInYiLCJtdWx0aXBsZSIsInNvbWUiLCJjYXBpdGFsaXplU3RhcnQiLCJzdHIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiSU5URVJOQUxfZG9Gb3JtYXR0aW5nIiwiYWxsb3dlZFR5cGVzIiwiZm9ybWF0dGVkVHlwZXMiLCJmIiwibGVuZ3RoIiwibGFzdFR5cGUiLCJwb3AiLCJqb2luIiwia2V5IiwiZm9ybWF0dGVkS2V5IiwibWF4RmlsZVNpemUiLCJhbGxvd2VkQ29udGVudFRleHRMYWJlbEdlbmVyYXRvciIsInN0eWxlRmllbGRUb0NsYXNzTmFtZSIsInN0eWxlRmllbGQiLCJhcmdzIiwicmVzdWx0Iiwic3R5bGVGaWVsZFRvQ3NzT2JqZWN0IiwiY29udGVudEZpZWxkVG9Db250ZW50IiwiY29udGVudEZpZWxkIiwiYXJnIiwiSU5URVJOQUxfRE9fTk9UX1VTRV9fZmF0YWxDbGllbnRFcnJvciIsIkRBTkdFUk9VU19fdXBsb2FkRmlsZXMiLCJnbG9iYWxUaGlzIiwiYmluZCIsInJlcG9ydEV2ZW50VG9VVCIsIlN0cmluZyIsInMzQ29ubmVjdGlvblJlcyIsImlucHV0IiwiZmlsZXMiLCJuYW1lIiwic2l6ZSIsInRoZW4iLCJlcnJvciIsImZyb21SZXNwb25zZSIsImpzb25PckVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwiZmlsZVVwbG9hZFByb21pc2VzIiwicHJlc2lnbmVkIiwiZmlsZSIsImZpbmQiLCJjb25zb2xlIiwib25VcGxvYWRCZWdpbiIsInVwbG9hZE11bHRpcGFydCIsInIiLCJ1cGxvYWRQcmVzaWduZWRQb3N0Iiwic2VydmVyRGF0YSIsInBvbGxpbmdVcmwiLCJhdXRob3JpemF0aW9uIiwicG9sbGluZ0p3dCIsImpzb24iLCJjYWxsYmFja0RhdGEiLCJ1bmRlZmluZWQiLCJhbGwiLCJnZW5VcGxvYWRlciIsImluaXRPcHRzIiwidXRQa2ciLCJjbGFzc05hbWVzIiwiY2xhc3NlcyIsImZpbHRlciIsIkJvb2xlYW4iLCJnZW5lcmF0ZU1pbWVUeXBlcyIsImFjY2VwdGVkIiwiaW5jbHVkZXMiLCJnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0IiwibWltZVR5cGVzIiwiZnJvbUVudHJpZXMiLCJldGFncyIsInVwbG9hZGVkQnl0ZXMiLCJ1cmxzIiwiaW5kZXgiLCJvZmZzZXQiLCJjaHVua1NpemUiLCJlbmQiLCJtaW4iLCJwZXJjZW50Iiwib25VcGxvYWRQcm9ncmVzcyIsInByb2dyZXNzIiwidGFnIiwicGFydE51bWJlciIsImZpbGVLZXkiLCJ1cGxvYWRJZCIsInVwbG9hZE9rIiwibG9nIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImVudHJpZXMiLCJmaWVsZHMiLCJmb3JFYWNoIiwiayIsImFwcGVuZCIsInRvdGFsIiwidGFyZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uploadthing/client/index.js\n");

/***/ })

};
;